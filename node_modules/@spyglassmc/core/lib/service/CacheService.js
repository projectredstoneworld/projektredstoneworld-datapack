import { Uri } from '../common/index.js';
import { SymbolTable } from '../symbol/index.js';
import { ArchiveUriSupporter } from './FileService.js';
import { fileUtil } from './fileUtil.js';
/**
 * The format version of the cache. Should be increased when any changes that
 * could invalidate the cache are introduced to the Spyglass codebase.
 */
export const LatestCacheVersion = 6;
var Checksums;
(function (Checksums) {
    function create() {
        return { files: {}, roots: {}, symbolRegistrars: {} };
    }
    Checksums.create = create;
})(Checksums || (Checksums = {}));
export class CacheService {
    cacheRoot;
    project;
    checksums = Checksums.create();
    errors = {};
    #hasValidatedFiles = false;
    /**
     * @param cacheRoot File path to the directory where cache files by Spyglass should be stored.
     * @param project
     */
    constructor(cacheRoot, project) {
        this.cacheRoot = cacheRoot;
        this.project = project;
        this.project.on('documentUpdated', async ({ doc }) => {
            if (!this.#hasValidatedFiles
                // Do not save checksums for file schemes that we cannot map to disk (e.g. 'untitled:'
                // for untitled files in VS Code)
                || !(doc.uri.startsWith(ArchiveUriSupporter.Protocol) || doc.uri.startsWith('file:'))) {
                return;
            }
            try {
                // TODO: Don't update this for every single change.
                this.checksums.files[doc.uri] = await this.project.externals.crypto.getSha1(doc.getText());
            }
            catch (e) {
                if (!this.project.externals.error.isKind(e, 'EISDIR')) {
                    this.project.logger.error(`[CacheService#hash-file] ${doc.uri}`);
                }
            }
        });
        this.project.on('rootsUpdated', async ({ roots }) => {
            if (!this.#hasValidatedFiles) {
                return;
            }
            for (const root of roots) {
                try {
                    this.checksums.roots[root] = await this.project.fs.hash(root);
                }
                catch (e) {
                    if (!this.project.externals.error.isKind(e, 'EISDIR')) {
                        this.project.logger.error(`[CacheService#hash-root] ${root}`, e);
                    }
                }
            }
        });
        this.project.on('symbolRegistrarExecuted', ({ id, checksum }) => {
            if (checksum !== undefined) {
                this.checksums.symbolRegistrars[id] = checksum;
            }
        });
        this.project.on('documentErrored', ({ uri, errors }) => {
            this.errors[uri] = errors;
        });
    }
    #cacheFilePath;
    async getCacheFileUri() {
        if (!this.#cacheFilePath) {
            const sortedRoots = [...this.project.projectRoots].sort();
            const hash = await this.project.externals.crypto.getSha1(sortedRoots.join(':'));
            this.#cacheFilePath = new Uri(`symbols/${hash}.json.gz`, this.cacheRoot).toString();
        }
        return this.#cacheFilePath;
    }
    async load() {
        const ans = { symbols: {} };
        if (this.project.projectRoots.length === 0) {
            return ans;
        }
        const __profiler = this.project.profilers.get('cache#load');
        let filePath;
        try {
            filePath = await this.getCacheFileUri();
            this.project.logger.info(`[CacheService#load] symbolCachePath = ${filePath}`);
            const cache = (await fileUtil.readGzippedJson(this.project.externals, filePath));
            __profiler.task('Read File');
            if (cache.version === LatestCacheVersion) {
                this.checksums = cache.checksums;
                this.errors = cache.errors;
                ans.symbols = SymbolTable.link(cache.symbols);
                __profiler.task('Link Symbols');
            }
            else {
                this.project.logger.info(`[CacheService#load] Unsupported cache format ${cache.version}; expected ${LatestCacheVersion}`);
            }
        }
        catch (e) {
            if (!this.project.externals.error.isKind(e, 'ENOENT')) {
                this.project.logger.error('[CacheService#load] ', e);
            }
        }
        __profiler.finalize();
        return ans;
    }
    async validate() {
        const ans = {
            addedFiles: [],
            changedFiles: [],
            removedFiles: [],
            unchangedFiles: [],
        };
        const unchangedRoots = [];
        for (const [uri, checksum] of Object.entries(this.checksums.roots)) {
            try {
                const hash = await this.project.fs.hash(uri);
                if (hash === checksum) {
                    unchangedRoots.push(uri);
                }
            }
            catch (e) {
                if (!this.project.externals.error.isKind(e, 'EISDIR')) {
                    this.project.logger.error(`[CacheService#hash-file] ${uri}`);
                }
                // Failed calculating hash. Assume the root has changed.
            }
        }
        for (const [uri, checksum] of Object.entries(this.checksums.files)) {
            if (unchangedRoots.some((root) => fileUtil.isSubUriOf(uri, root))) {
                ans.unchangedFiles.push(uri);
                continue;
            }
            if (this.project.shouldExclude(uri)) {
                ans.removedFiles.push(uri);
                continue;
            }
            try {
                const hash = await this.project.fs.hash(uri);
                if (hash === checksum) {
                    ans.unchangedFiles.push(uri);
                }
                else {
                    ans.changedFiles.push(uri);
                }
            }
            catch (e) {
                if (this.project.externals.error.isKind(e, 'ENOENT')
                    || this.project.externals.error.isKind(e, 'EISDIR')) {
                    ans.removedFiles.push(uri);
                }
                else {
                    this.project.logger.error(`[CacheService#validate] ${uri}`, e);
                    // Assume the file has changed.
                    ans.changedFiles.push(uri);
                }
            }
        }
        for (const uri of this.project.getTrackedFiles()) {
            if (!(uri in this.checksums.files)) {
                ans.addedFiles.push(uri);
            }
        }
        this.#hasValidatedFiles = true;
        return ans;
    }
    /**
     * @returns If the cache file was saved successfully.
     */
    async save() {
        if (this.project.projectRoots.length === 0) {
            return false;
        }
        const __profiler = this.project.profilers.get('cache#save');
        let filePath;
        try {
            filePath = await this.getCacheFileUri();
            const cache = {
                version: LatestCacheVersion,
                projectRoots: this.project.projectRoots,
                checksums: this.checksums,
                symbols: SymbolTable.unlink(this.project.symbols.global),
                errors: this.errors,
            };
            __profiler.task('Unlink Symbols');
            await fileUtil.writeGzippedJson(this.project.externals, filePath, cache);
            __profiler.task('Write File').finalize();
            return true;
        }
        catch (e) {
            this.project.logger.error(`[CacheService#save] path = ${filePath}`, e);
        }
        return false;
    }
    async hasFileChangedSinceCache(doc) {
        return (this.checksums.files[doc.uri]
            !== (await this.project.externals.crypto.getSha1(doc.getText())));
    }
    reset() {
        this.#hasValidatedFiles = false;
        this.checksums = Checksums.create();
        this.errors = {};
        return { symbols: {} };
    }
}
//# sourceMappingURL=CacheService.js.map