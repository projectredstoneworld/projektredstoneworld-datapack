/* istanbul ignore file */
import { Uri } from '../common/index.js';
import { TwoWayMap } from '../common/TwoWayMap.js';
import { fileUtil } from './fileUtil.js';
export var FileService;
(function (FileService) {
    function create(externals, cacheRoot) {
        const virtualUrisRoot = fileUtil.ensureEndingSlash(new Uri('virtual-uris/', cacheRoot).toString());
        return new FileServiceImpl(externals, virtualUrisRoot);
    }
    FileService.create = create;
})(FileService || (FileService = {}));
export class FileServiceImpl {
    externals;
    virtualUrisRoot;
    supporters = new Map();
    /**
     * A two-way map from mapped physical URIs to virtual URIs.
     */
    map = new TwoWayMap();
    constructor(externals, virtualUrisRoot) {
        this.externals = externals;
        this.virtualUrisRoot = virtualUrisRoot;
    }
    register(protocol, supporter, force = false) {
        if (!force && this.supporters.has(protocol)) {
            throw new Error(`The protocol “${protocol}” is already associated with another supporter.`);
        }
        this.supporters.set(protocol, supporter);
    }
    unregister(protocol) {
        this.supporters.delete(protocol);
    }
    /**
     * @throws If the protocol of `uri` isn't supported.
     *
     * @returns The protocol if it's supported.
     */
    getSupportedProtocol(uri) {
        const protocol = new Uri(uri).protocol;
        if (!this.supporters.has(protocol)) {
            throw new Error(`The protocol “${protocol}” is unsupported.`);
        }
        return protocol;
    }
    /**
     * @throws
     */
    async hash(uri) {
        const protocol = this.getSupportedProtocol(uri);
        return this.supporters.get(protocol).hash(uri);
    }
    /**
     * @throws
     */
    readFile(uri) {
        const protocol = this.getSupportedProtocol(uri);
        return this.supporters.get(protocol).readFile(uri);
    }
    *listFiles() {
        for (const supporter of this.supporters.values()) {
            yield* supporter.listFiles();
        }
    }
    *listRoots() {
        for (const supporter of this.supporters.values()) {
            yield* supporter.listRoots();
        }
    }
    async mapToDisk(virtualUri) {
        if (fileUtil.isFileUri(virtualUri)) {
            return virtualUri;
        }
        if (!this.virtualUrisRoot) {
            return undefined;
        }
        try {
            let mappedUri = this.map.getKey(virtualUri);
            if (mappedUri === undefined) {
                mappedUri = `${this.virtualUrisRoot}${await this.externals.crypto.getSha1(virtualUri)}/${fileUtil.basename(virtualUri)}`;
                // Delete old mapped file if it exists. This makes sure the
                // readonly permission on the file is not removed by it being
                // overwritten.
                try {
                    await fileUtil.unlink(this.externals, mappedUri);
                }
                catch (e) {
                    if (!this.externals.error.isKind(e, 'ENOENT')) {
                        throw e;
                    }
                }
                const buffer = await this.readFile(virtualUri);
                await fileUtil.writeFile(this.externals, mappedUri, buffer, 0o444);
                this.map.set(mappedUri, virtualUri);
            }
            return mappedUri;
        }
        catch (e) {
            // Ignored.
        }
        return undefined;
    }
    mapFromDisk(mappedUri) {
        if (!this.virtualUrisRoot) {
            return mappedUri;
        }
        return this.map.get(mappedUri) ?? mappedUri;
    }
}
export class FileUriSupporter {
    externals;
    roots;
    files;
    protocol = 'file:';
    constructor(externals, roots, files) {
        this.externals = externals;
        this.roots = roots;
        this.files = files;
    }
    async hash(uri) {
        return hashFile(this.externals, uri);
    }
    readFile(uri) {
        return this.externals.fs.readFile(uri);
    }
    *listFiles() {
        for (const files of this.files.values()) {
            yield* files;
        }
    }
    listRoots() {
        return this.roots;
    }
    async mapToDisk(uri) {
        return uri;
    }
    static async create(dependencies, externals, logger) {
        const roots = [];
        const files = new Map();
        for (const dependency of dependencies) {
            if (dependency.type !== 'directory') {
                continue;
            }
            let { uri } = dependency;
            try {
                if (fileUtil.isFileUri(uri) && (await externals.fs.stat(uri)).isDirectory()) {
                    uri = fileUtil.ensureEndingSlash(uri);
                    roots.push(uri);
                    files.set(uri, await fileUtil.getAllFiles(externals, uri));
                }
            }
            catch (e) {
                logger.error(`[FileUriSupporter#create] Bad dependency ${uri}`, e);
            }
        }
        return new FileUriSupporter(externals, roots, files);
    }
}
export class ArchiveUriSupporter {
    externals;
    logger;
    archiveHashes;
    entries;
    static Protocol = 'archive:';
    protocol = ArchiveUriSupporter.Protocol;
    /**
     * @param entries A map from archive names to unzipped entries.
     */
    constructor(externals, logger, archiveHashes, entries) {
        this.externals = externals;
        this.logger = logger;
        this.archiveHashes = archiveHashes;
        this.entries = entries;
    }
    async hash(uri) {
        const { archiveName, pathInArchive } = ArchiveUriSupporter.decodeUri(new Uri(uri));
        if (!pathInArchive) {
            // Return hash of the archive itself.
            if (!this.archiveHashes.has(archiveName)) {
                throw new Error(`No archiveHashes entry for ${archiveName}`);
            }
            return this.archiveHashes.get(archiveName);
        }
        else {
            // Hash the corresponding file.
            return this.externals.crypto.getSha1(this.getDataInArchive(archiveName, pathInArchive));
        }
    }
    async readFile(uri) {
        const { archiveName, pathInArchive } = ArchiveUriSupporter.decodeUri(new Uri(uri));
        return this.getDataInArchive(archiveName, pathInArchive);
    }
    /**
     * @throws
     */
    getDataInArchive(archiveName, pathInArchive) {
        const entries = this.entries.get(archiveName);
        if (!entries) {
            throw this.externals.error.createKind('ENOENT', `Archive “${archiveName}” has not been loaded into the memory`);
        }
        const entry = entries.get(pathInArchive);
        if (!entry) {
            throw this.externals.error.createKind('ENOENT', `Path “${pathInArchive}” does not exist in archive “${archiveName}”`);
        }
        if (entry.type !== 'file') {
            throw this.externals.error.createKind('EISDIR', `Path “${pathInArchive}” in archive “${archiveName}” is not a file`);
        }
        return entry.data;
    }
    *listFiles() {
        for (const [archiveName, entries] of this.entries.entries()) {
            this.logger.info(`[ArchiveUriSupporter#listFiles] Listing ${entries.size} entries from ${archiveName}`);
            for (const entry of entries.values()) {
                if (entry.type === 'file') {
                    yield ArchiveUriSupporter.getUri(archiveName, entry.path);
                }
            }
        }
    }
    *listRoots() {
        for (const archiveName of this.entries.keys()) {
            yield ArchiveUriSupporter.getUri(archiveName);
        }
    }
    static getUri(archiveName, pathInArchive = '') {
        return `${ArchiveUriSupporter.Protocol}//${archiveName}/${pathInArchive.replace(/\\/g, '/')}`;
    }
    /**
     * @throws When `uri` has the wrong protocol or hostname.
     */
    static decodeUri(uri) {
        if (uri.protocol !== ArchiveUriSupporter.Protocol) {
            throw new Error(`Expected protocol “${ArchiveUriSupporter.Protocol}” in ${uri}`);
        }
        const path = uri.pathname;
        if (!path) {
            throw new Error(`Missing path in archive uri ${uri}`);
        }
        return { archiveName: uri.host, pathInArchive: path.charAt(0) === '/' ? path.slice(1) : path };
    }
    static async create(dependencies, externals, logger) {
        const archiveHashes = new Map();
        const entries = new Map();
        for (const dependency of dependencies) {
            if (dependency.type === 'directory') {
                continue;
            }
            const archiveName = dependency.type === 'tarball-file'
                ? fileUtil.basename(dependency.uri)
                : dependency.name;
            try {
                if (entries.has(archiveName)) {
                    throw new Error(`A different archive with ${archiveName} already exists`);
                }
                const bytes = dependency.type === 'tarball-file'
                    ? await externals.fs.readFile(dependency.uri)
                    : dependency.data;
                const files = await externals.archive.decompressBall(bytes, { stripLevel: dependency.stripLevel ?? 0 });
                /// Debug message for #1609
                logger.info(`[ArchiveUriSupporter#create] Extracted ${files.length} files from ${archiveName}`);
                const hash = await externals.crypto.getSha1(bytes);
                archiveHashes.set(archiveName, hash);
                entries.set(archiveName, new Map(files.map((f) => [f.path.replace(/\\/g, '/'), f])));
            }
            catch (e) {
                logger.error(`[ArchiveUriSupporter#create] Bad dependency ${archiveName}`, e);
            }
        }
        return new ArchiveUriSupporter(externals, logger, archiveHashes, entries);
    }
}
async function hashFile(externals, uri) {
    return externals.crypto.getSha1(await externals.fs.readFile(uri));
}
//# sourceMappingURL=FileService.js.map