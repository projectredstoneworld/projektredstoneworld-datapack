import type { TextDocumentContentChangeEvent } from 'vscode-languageserver-textdocument';
import { TextDocument } from 'vscode-languageserver-textdocument';
import type { ExternalEventEmitter, Externals } from '../common/index.js';
import { Logger, UriStore } from '../common/index.js';
import type { AstNode } from '../node/index.js';
import { FileNode } from '../node/index.js';
import type { PosRangeLanguageError } from '../source/index.js';
import { SymbolUtil } from '../symbol/index.js';
import { CacheService } from './CacheService.js';
import type { Config, PartialConfig } from './Config.js';
import { FileService } from './FileService.js';
import type { RootUriString } from './fileUtil.js';
import type { FileWatcher } from './FileWatcher.js';
import { MetaRegistry } from './MetaRegistry.js';
import { ProfilerFactory } from './Profiler.js';
export type ProjectInitializerContext = Pick<Project, 'cacheRoot' | 'config' | 'externals' | 'isDebugging' | 'logger' | 'meta' | 'projectRoots'>;
export type SyncProjectInitializer = (this: void, ctx: ProjectInitializerContext) => Record<string, string> | void;
export type AsyncProjectInitializer = (this: void, ctx: ProjectInitializerContext) => PromiseLike<Record<string, string> | void>;
export type ProjectInitializer = SyncProjectInitializer | AsyncProjectInitializer;
export interface ProjectOptions {
    cacheRoot: RootUriString;
    defaultConfig?: Config;
    externals: Externals;
    fs?: FileService;
    initializers?: readonly ProjectInitializer[];
    isDebugging?: boolean;
    logger?: Logger;
    profilers?: ProfilerFactory;
    /**
     * File URIs to the roots of this project.
     */
    projectRoots: RootUriString[];
    symbols?: SymbolUtil;
}
export interface ProjectReadyOptions {
    projectRootsWatcher?: FileWatcher;
}
export interface DocAndNode {
    doc: TextDocument;
    node: FileNode<AstNode>;
}
interface DocumentEvent extends DocAndNode {
}
interface DocumentErrorEvent {
    errors: readonly PosRangeLanguageError[];
    uri: string;
    version?: number;
}
export interface ConfigChangeEvent {
    oldConfig: Config;
    newConfig: Config;
}
interface FileEvent {
    uri: string;
}
interface EmptyEvent {
}
interface RootsEvent {
    roots: readonly RootUriString[];
}
interface SymbolRegistrarEvent {
    id: string;
    checksum: string | undefined;
}
export type ProjectData = Pick<Project, 'cacheRoot' | 'config' | 'ensureBindingStarted' | 'externals' | 'fs' | 'isDebugging' | 'logger' | 'meta' | 'profilers' | 'projectRoots' | 'roots' | 'symbols' | 'ctx'>;
/**
 * Manage all tracked documents and errors.
 *
 * The four stages of processing a document:
 * 1. `read` - read the file from the external file system as a `TextDocument`.
 * 2. `parse` - Parse the `TextDocument` into an `AstNode`.
 * 3. `bind` - Bind the `AstNode` and populate both the global symbol table and the local symbol tables on the nodes.
 * 4. `check` (includes `lint`) - Check the `AstNode` with information from the symbol tables.
 *
 * **Caching**
 *
 * The global symbol table along with a list of file URIs and checksums is cached in memory and is periodically saved to disk.
 *
 * The `TextDocument`s and file `AstNode`s (including their local symbol tables) managed by the client are stored in memory until the client sends a `didClose` notification.
 *
 * Some `TextDocument`s may be cached to avoid excessive reading from the file system.
 *
 * **INIT and READY**
 *
 * When a new instance of the {@link Project} class is constructed, its INIT and READY processes are immediately started in serial.
 *
 * During the INIT process of the project, the config and language feature initialization are processed.
 * The Promise returned by the {@link init} function resolves when the INIT process is complete.
 *
 * During the READY process of the project, the whole project is analyzed mainly to populate the global symbol table.
 * The Promise returned by the {@link ready} function resolves when the READY process is complete.
 *
 * The following generally happens during the READY process:
 * 1. A list of file URIs under the project is obtained.
 * 2. The global symbol cache, if available, is loaded and validated against the know list of files.
 *    A list of files that need to be (re)processed is returned in this step.
 * 3. For each files in the new list, the file is read, parsed, bound, and checked.
 *
 * **EDITING**
 *
 * After the READY process is complete, editing text documents as signaled by the client or the file watcher results in the file being re-processed.
 */
export declare class Project implements ExternalEventEmitter {
    #private;
    private static readonly RootSuffix;
    readonly cacheService: CacheService;
    get watchedFiles(): UriStore;
    get isReady(): boolean;
    config: Config;
    readonly externals: Externals;
    readonly fs: FileService;
    readonly isDebugging: boolean;
    readonly logger: Logger;
    readonly meta: MetaRegistry;
    readonly profilers: ProfilerFactory;
    readonly projectRoots: RootUriString[];
    symbols: SymbolUtil;
    /**
     * All tracked root URIs. Each URI in this array is guaranteed to end with a slash (`/`).
     *
     * Includes the roots of all dependencies, the project root, and all data pack roots identified
     * by `pack.mcmeta` files.
     *
     * Some URIs in the array may overlap with each other. In such cases, the deeper ones are guaranteed to come
     * before the shallower ones (e.g. `file:///foo/bar/` will come before `file:///foo/`).
     */
    get roots(): readonly RootUriString[];
    /**
     * Arbitrary information that will be included in the `project` property of all `Context`s.
     */
    get ctx(): Record<string, string>;
    /**
     * File URI to a directory where all cache files of Spyglass should be stored.
     */
    get cacheRoot(): RootUriString;
    private updateRoots;
    on(event: 'documentErrored', callbackFn: (data: DocumentErrorEvent) => void): this;
    on(event: 'documentUpdated', callbackFn: (data: DocumentEvent) => void): this;
    on(event: 'documentRemoved', callbackFn: (data: FileEvent) => void): this;
    on(event: `file${'Created' | 'Modified' | 'Deleted'}`, callbackFn: (data: FileEvent) => void): this;
    on(event: 'ready', callbackFn: (data: EmptyEvent) => void): this;
    on(event: 'rootsUpdated', callbackFn: (data: RootsEvent) => void): this;
    on(event: 'symbolRegistrarExecuted', callbackFn: (data: SymbolRegistrarEvent) => void): this;
    on(event: 'configChanged', callbackFn: (data: ConfigChangeEvent) => void): this;
    once(event: 'documentErrored', callbackFn: (data: DocumentErrorEvent) => void): this;
    once(event: 'documentUpdated', callbackFn: (data: DocumentEvent) => void): this;
    once(event: 'documentRemoved', callbackFn: (data: FileEvent) => void): this;
    once(event: `file${'Created' | 'Modified' | 'Deleted'}`, callbackFn: (data: FileEvent) => void): this;
    once(event: 'ready', callbackFn: (data: EmptyEvent) => void): this;
    once(event: 'rootsUpdated', callbackFn: (data: RootsEvent) => void): this;
    once(event: 'symbolRegistrarExecuted', callbackFn: (data: SymbolRegistrarEvent) => void): this;
    once(event: 'configChanged', callbackFn: (data: ConfigChangeEvent) => void): this;
    emit(event: 'documentErrored', data: DocumentErrorEvent): boolean;
    emit(event: 'documentUpdated', data: DocumentEvent): boolean;
    emit(event: 'documentRemoved', data: FileEvent): boolean;
    emit(event: `file${'Created' | 'Modified' | 'Deleted'}`, data: FileEvent): boolean;
    emit(event: 'ready', data: EmptyEvent): boolean;
    emit(event: 'rootsUpdated', data: RootsEvent): boolean;
    emit(event: 'symbolRegistrarExecuted', data: SymbolRegistrarEvent): boolean;
    emit(event: 'configChanged', data: ConfigChangeEvent): boolean;
    /**
     * Get all files that are tracked and supported.
     *
     * Files in cached archives may not show up in the result as those files
     * are not loaded into the memory.
     */
    getTrackedFiles(): string[];
    constructor({ cacheRoot, defaultConfig, externals, fs, initializers, isDebugging, logger, profilers, projectRoots, }: ProjectOptions);
    /**
     * Load the config file and initialize parsers and processors.
     */
    init(): Promise<this>;
    /**
     * Finish the initial run of parsing, binding, and checking the entire project.
     */
    ready(options?: ProjectReadyOptions): Promise<this>;
    /**
     * Behavior of the `Project` instance is undefined after this function has settled.
     */
    close(): Promise<void>;
    restart(): Promise<void>;
    resetCache(): Promise<void>;
    normalizeUri(uri: string): string;
    private static readonly TextDocumentCacheMaxLength;
    private removeCachedTextDocument;
    private read;
    private parse;
    private bind;
    private check;
    private lint;
    ensureBindingStarted(uri: string): Promise<void>;
    private bindUri;
    /**
     * Notify that a new document was opened in the editor.
     */
    onDidOpen(uri: string, languageID: string, version: number, content: string): Promise<void>;
    /**
     * Notify that an existing document was changed in the editor.
     * @throws If there is no `TextDocument` corresponding to the URI.
     */
    onDidChange(uri: string, changes: TextDocumentContentChangeEvent[], version: number): Promise<void>;
    /**
     * Notify that an existing document was closed in the editor.
     */
    onDidClose(uri: string): void;
    ensureClientManagedChecked(uri: string): Promise<DocAndNode | undefined>;
    getClientManaged(uri: string): DocAndNode | undefined;
    showCacheRoot(): Promise<void>;
    /**
     * Returns true iff the URI should be excluded from all Spyglass language support.
     *
     * @param language Optional. If ommitted, a language will be derived from the URI according to
     *                 its file extension.
     */
    shouldExclude(uri: string, language?: string): boolean;
    private isSupportedLanguage;
    /**
     * Guess a language ID from a URI. The guessed language ID may or may not actually be supported.
     */
    private guessLanguageID;
    private isUserExcluded;
    private tryClearingCache;
    private shouldRemove;
    private isOnlyWatched;
    onEditorConfigurationUpdate(editorConfiguration: PartialConfig): Promise<void>;
}
export {};
//# sourceMappingURL=Project.d.ts.map