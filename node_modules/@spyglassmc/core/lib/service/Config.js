import rfdc from 'rfdc';
import { Arrayable, bufferToString, merge, TypePredicates } from '../common/index.js';
import { ErrorSeverity } from '../source/index.js';
import { DataFileCategories, RegistryCategories } from '../symbol/index.js';
export var LinterSeverity;
(function (LinterSeverity) {
    function is(value) {
        return (value === 'hint'
            || value === 'information'
            || value === 'warning'
            || value === 'error');
    }
    LinterSeverity.is = is;
    function toErrorSeverity(value) {
        switch (value) {
            case 'error':
                return ErrorSeverity.Error;
            case 'hint':
                return ErrorSeverity.Hint;
            case 'information':
                return ErrorSeverity.Information;
            case 'warning':
                return ErrorSeverity.Warning;
        }
    }
    LinterSeverity.toErrorSeverity = toErrorSeverity;
})(LinterSeverity || (LinterSeverity = {}));
export var LinterConfigValue;
(function (LinterConfigValue) {
    function destruct(value) {
        if (value === null || value === undefined) {
            return undefined;
        }
        if (LinterSeverity.is(value)) {
            return { ruleSeverity: LinterSeverity.toErrorSeverity(value), ruleValue: true };
        }
        if (Array.isArray(value) && LinterSeverity.is(value[0])) {
            return { ruleSeverity: LinterSeverity.toErrorSeverity(value[0]), ruleValue: value[1] };
        }
        return { ruleSeverity: ErrorSeverity.Warning, ruleValue: value };
    }
    LinterConfigValue.destruct = destruct;
})(LinterConfigValue || (LinterConfigValue = {}));
export var SymbolLinterConfig;
(function (SymbolLinterConfig) {
    function is(value) {
        return Arrayable.is(value, Complex.is) || Action.is(value);
    }
    SymbolLinterConfig.is = is;
    let Complex;
    (function (Complex) {
        function is(v) {
            if (!v || typeof v !== 'object') {
                return false;
            }
            const value = v;
            return ((value.if === undefined || Arrayable.is(value.if, Condition.is))
                && (value.then === undefined || Action.is(value.then))
                && (value.override === undefined || Arrayable.is(value.override, Complex.is)));
        }
        Complex.is = is;
    })(Complex = SymbolLinterConfig.Complex || (SymbolLinterConfig.Complex = {}));
    let Condition;
    (function (Condition) {
        function is(v) {
            if (!v || typeof v !== 'object') {
                return false;
            }
            const value = v;
            return ((value.category === undefined
                || Arrayable.is(value.category, TypePredicates.isString))
                && (value.pattern === undefined || Arrayable.is(value.pattern, TypePredicates.isString))
                && (value.excludePattern === undefined
                    || Arrayable.is(value.excludePattern, TypePredicates.isString))
                && (value.namespace === undefined
                    || Arrayable.is(value.namespace, TypePredicates.isString))
                && (value.excludeNamespace === undefined
                    || Arrayable.is(value.excludeNamespace, TypePredicates.isString)));
        }
        Condition.is = is;
    })(Condition = SymbolLinterConfig.Condition || (SymbolLinterConfig.Condition = {}));
    let Action;
    (function (Action) {
        function isDeclare(value) {
            return (value !== undefined
                && ['block', 'file', 'public'].includes(value.declare));
        }
        Action.isDeclare = isDeclare;
        function isReport(value) {
            return (value !== undefined
                && ['inherit', 'hint', 'information', 'warning', 'error'].includes(value.report));
        }
        Action.isReport = isReport;
        function is(v) {
            if (!v || typeof v !== 'object') {
                return false;
            }
            const value = v;
            return isDeclare(value) || isReport(value);
        }
        Action.is = is;
    })(Action = SymbolLinterConfig.Action || (SymbolLinterConfig.Action = {}));
})(SymbolLinterConfig || (SymbolLinterConfig = {}));
/**
 * Config which simulates the default vanilla command system.
 */
export const VanillaConfig = {
    env: {
        dependencies: ['@vanilla-datapack', '@vanilla-resourcepack', '@vanilla-mcdoc'],
        exclude: [
            '.*/**',
            '**/node_modules/**',
            '**/__pycache__/**',
        ],
        customResources: {},
        feature: {
            codeActions: true,
            colors: true,
            completions: true,
            documentHighlighting: true,
            documentLinks: true,
            foldingRanges: true,
            formatting: true,
            hover: true,
            inlayHint: {
                enabledNodes: [
                    'boolean',
                    'double',
                    'float',
                    'integer',
                    'long',
                    'mcfunction:coordinate',
                    'mcfunction:vector',
                    'mcfunction:command_child/unknown',
                ],
            },
            semanticColoring: true,
            selectionRanges: true,
            signatures: true,
        },
        gameVersion: 'Auto',
        permissionLevel: 2,
        plugins: [],
        mcmetaSummaryOverrides: {},
        enableMcdocCaching: false,
    },
    format: {
        blockStateBracketSpacing: { inside: 0 },
        blockStateCommaSpacing: { before: 0, after: 1 },
        blockStateEqualSpacing: { before: 0, after: 0 },
        blockStateTrailingComma: false,
        eol: 'auto',
        nbtArrayBracketSpacing: { inside: 0 },
        nbtArrayCommaSpacing: { before: 0, after: 1 },
        nbtArraySemicolonSpacing: { after: 1 },
        nbtArrayTrailingComma: false,
        nbtByteSuffix: 'b',
        nbtCompoundBracketSpacing: { inside: 0 },
        nbtCompoundColonSpacing: { before: 0, after: 1 },
        nbtCompoundCommaSpacing: { before: 0, after: 1 },
        nbtCompoundTrailingComma: false,
        nbtDoubleOmitSuffix: false,
        nbtDoubleSuffix: 'd',
        nbtFloatSuffix: 'f',
        nbtListBracketSpacing: { inside: 0 },
        nbtListCommaSpacing: { before: 0, after: 1 },
        nbtListTrailingComma: false,
        nbtLongSuffix: 'L',
        nbtShortSuffix: 's',
        selectorBracketSpacing: { inside: 0 },
        selectorCommaSpacing: { before: 0, after: 1 },
        selectorEqualSpacing: { before: 0, after: 0 },
        selectorTrailingComma: false,
        timeOmitTickUnit: false,
    },
    lint: {
        blockStateSortKeys: null,
        nbtCompoundSortKeys: null,
        selectorSortKeys: null,
        commandStringQuote: null,
        nbtKeyQuote: null,
        nbtPathQuote: null,
        nbtStringQuote: null,
        selectorKeyQuote: null,
        idOmitDefaultNamespace: null,
        nameOfNbtKey: null,
        nameOfObjective: null,
        nameOfScoreHolder: null,
        nameOfTag: null,
        nameOfTeam: null,
        nbtArrayLengthCheck: true,
        nbtBoolean: null,
        nbtListLengthCheck: null,
        nbtTypeCheck: 'loosely',
        undeclaredSymbol: [
            {
                if: [
                    { category: RegistryCategories, namespace: 'minecraft' },
                    { category: [...DataFileCategories, 'bossbar', 'objective', 'stopwatch', 'team'] },
                ],
                then: { report: 'warning' },
            },
            {
                if: { category: ['attribute_modifier', 'attribute_modifier_uuid', 'tag'] },
                then: { declare: 'public' },
            },
            {
                then: { declare: 'block' },
            },
        ],
    },
    snippet: {
        executeIfScoreSet: 'execute if score ${1:score_holder} ${2:objective} = ${1:score_holder} ${2:objective} $0',
        summonAec: 'summon minecraft:area_effect_cloud ~ ~ ~ {Age: -2147483648, Duration: -1, WaitTime: -2147483648, Tags: ["${1:tag}"]}',
    },
};
export var PartialConfig;
(function (PartialConfig) {
    /**
     * Filters a config for valid editor settings
     * @param spyglassmcConfiguration An unchecked config, should have the same layout as {@link PartialConfig}
     * @returns The config, only keeping editor settings that have valid values
     */
    function buildConfigFromEditorSettingsSafe(spyglassmcConfiguration) {
        const result = {};
        if (!spyglassmcConfiguration || typeof spyglassmcConfiguration !== 'object') {
            return result;
        }
        if (spyglassmcConfiguration.env && typeof spyglassmcConfiguration.env === 'object') {
            result.env = {};
            if (typeof spyglassmcConfiguration.env.gameVersion === 'string') {
                result.env.gameVersion = spyglassmcConfiguration.env.gameVersion;
            }
            if (typeof spyglassmcConfiguration.env.enableMcdocCaching === 'boolean') {
                result.env.enableMcdocCaching = spyglassmcConfiguration.env.enableMcdocCaching;
            }
            if (spyglassmcConfiguration.env.feature
                && typeof spyglassmcConfiguration.env.feature === 'object') {
                result.env.feature = {};
                if (typeof spyglassmcConfiguration.env.feature.codeActions === 'boolean') {
                    result.env.feature.codeActions = spyglassmcConfiguration.env.feature.codeActions;
                }
                if (typeof spyglassmcConfiguration.env.feature.colors === 'boolean') {
                    result.env.feature.colors = spyglassmcConfiguration.env.feature.colors;
                }
                if (typeof spyglassmcConfiguration.env.feature.completions === 'boolean') {
                    result.env.feature.completions = spyglassmcConfiguration.env.feature.completions;
                }
                if (typeof spyglassmcConfiguration.env.feature.documentHighlighting === 'boolean') {
                    result.env.feature.documentHighlighting =
                        spyglassmcConfiguration.env.feature.documentHighlighting;
                }
                if (typeof spyglassmcConfiguration.env.feature.documentLinks === 'boolean') {
                    result.env.feature.documentLinks = spyglassmcConfiguration.env.feature.documentLinks;
                }
                if (typeof spyglassmcConfiguration.env.feature.foldingRanges === 'boolean') {
                    result.env.feature.foldingRanges = spyglassmcConfiguration.env.feature.foldingRanges;
                }
                if (typeof spyglassmcConfiguration.env.feature.formatting === 'boolean') {
                    result.env.feature.formatting = spyglassmcConfiguration.env.feature.formatting;
                }
                if (typeof spyglassmcConfiguration.env.feature.hover === 'boolean') {
                    result.env.feature.hover = spyglassmcConfiguration.env.feature.hover;
                }
                if (spyglassmcConfiguration.env.feature.inlayHint
                    && typeof spyglassmcConfiguration.env.feature.inlayHint === 'object'
                    && Array.isArray(spyglassmcConfiguration.env.feature.inlayHint.enabledNodes)) {
                    result.env.feature.inlayHint = {
                        enabledNodes: spyglassmcConfiguration.env.feature.inlayHint.enabledNodes
                            .filter((element) => typeof element === 'string'),
                    };
                }
                if (typeof spyglassmcConfiguration.env.feature.semanticColoring === 'boolean') {
                    result.env.feature.semanticColoring =
                        spyglassmcConfiguration.env.feature.semanticColoring;
                }
                if (spyglassmcConfiguration.env.feature.semanticColoring
                    && typeof spyglassmcConfiguration.env.feature.semanticColoring === 'object'
                    && Array.isArray(spyglassmcConfiguration.env.feature.semanticColoring.disabledLanguages)) {
                    result.env.feature.semanticColoring = {
                        disabledLanguages: spyglassmcConfiguration.env.feature.semanticColoring
                            .disabledLanguages
                            .filter((element) => typeof element === 'string'),
                    };
                }
                if (typeof spyglassmcConfiguration.env.feature.selectionRanges === 'boolean') {
                    result.env.feature.selectionRanges =
                        spyglassmcConfiguration.env.feature.selectionRanges;
                }
                if (typeof spyglassmcConfiguration.env.feature.signatures === 'boolean') {
                    result.env.feature.signatures = spyglassmcConfiguration.env.feature.signatures;
                }
            }
        }
        return result;
    }
    PartialConfig.buildConfigFromEditorSettingsSafe = buildConfigFromEditorSettingsSafe;
})(PartialConfig || (PartialConfig = {}));
export class ConfigService {
    project;
    defaultConfig;
    static ConfigFileNames = Object.freeze(['spyglass.json', '.spyglassrc', '.spyglassrc.json']);
    #eventEmitter;
    currentEditorConfiguration = {};
    constructor(project, defaultConfig = VanillaConfig) {
        this.project = project;
        this.defaultConfig = defaultConfig;
        this.#eventEmitter = new project.externals.event.EventEmitter();
        const handler = async ({ uri }) => {
            if (ConfigService.isConfigFile(uri)) {
                this.emit('changed', { config: await this.load() });
            }
        };
        project.on('fileCreated', handler);
        project.on('fileModified', handler);
        project.on('fileDeleted', handler);
    }
    on(event, callbackFn) {
        this.#eventEmitter.on(event, callbackFn);
        return this;
    }
    once(event, callbackFn) {
        this.#eventEmitter.once(event, callbackFn);
        return this;
    }
    emit(event, ...args) {
        return this.#eventEmitter.emit(event, ...args);
    }
    async onEditorConfigurationUpdate(editorConfiguration) {
        this.currentEditorConfiguration = editorConfiguration;
        this.emit('changed', { config: await this.load() });
    }
    async load() {
        const overrides = [];
        for (const projectRoot of this.project.projectRoots) {
            for (const name of ConfigService.ConfigFileNames) {
                const uri = projectRoot + name;
                try {
                    const contents = await this.project.externals.fs.readFile(uri);
                    overrides.push(JSON.parse(bufferToString(contents)));
                }
                catch (e) {
                    if (this.project.externals.error.isKind(e, 'ENOENT')) {
                        // File doesn't exist.
                        continue;
                    }
                    this.emit('error', { error: e, uri });
                }
                break;
            }
        }
        return ConfigService.merge(this.defaultConfig, this.currentEditorConfiguration, ...overrides);
    }
    static isConfigFile(uri) {
        return ConfigService.ConfigFileNames.some((n) => uri.endsWith(`/${n}`));
    }
    static merge(base, ...overrides) {
        return overrides.reduce(merge, rfdc()(base));
    }
}
//# sourceMappingURL=Config.js.map