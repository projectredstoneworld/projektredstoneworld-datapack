var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
import { TextDocument } from 'vscode-languageserver-textdocument';
import { Range } from '../source/index.js';
import { SymbolLocation, SymbolPath, SymbolUsageTypes } from './Symbol.js';
export class SymbolUtil {
    #global;
    #eventEmitter;
    #eventEmitterConstructor;
    #trimmableSymbols = new Set();
    #cache = Object.create(null);
    #currentContributor;
    /**
     * @internal
     */
    _delayedOps = [];
    /**
     * @internal
     */
    _inDelayMode;
    get global() {
        return this.#global;
    }
    constructor(global, eventEmitterConstructor, 
    /** @internal */
    _currentContributor, 
    /** @internal */
    _inDelayMode = false) {
        this.#eventEmitter = new eventEmitterConstructor();
        this.#eventEmitterConstructor = eventEmitterConstructor;
        this.#global = global;
        this.#currentContributor = _currentContributor;
        this._inDelayMode = _inDelayMode;
        this.on('symbolCreated', ({ symbol }) => {
            this.#trimmableSymbols.add(SymbolPath.toString(symbol));
        }).on('symbolRemoved', ({ symbol }) => {
            this.#trimmableSymbols.delete(SymbolPath.toString(symbol));
        }).on('symbolLocationCreated', ({ symbol, location }) => {
            const cache = (this.#cache[location.contributor ?? 'undefined'] ??= Object.create(null));
            const fileSymbols = (cache[location.uri] ??= new Set());
            const path = SymbolPath.toString(symbol);
            fileSymbols.add(path);
            this.#trimmableSymbols.delete(path);
        }).on('symbolLocationRemoved', ({ symbol }) => {
            const path = SymbolPath.toString(symbol);
            this.#trimmableSymbols.add(path);
        });
    }
    on(event, callbackFn) {
        this.#eventEmitter.on(event, callbackFn);
        return this;
    }
    once(event, callbackFn) {
        this.#eventEmitter.once(event, callbackFn);
        return this;
    }
    emit(event, ...args) {
        return this.#eventEmitter.emit(event, ...args);
    }
    /**
     * Build the internal cache of the SymbolUtil according to the current global symbol table.
     */
    buildCache() {
        SymbolUtil.forEachSymbol(this.global, (symbol) => {
            this.emit('symbolCreated', { symbol });
            SymbolUtil.forEachLocationOfSymbol(symbol, ({ type, location }) => {
                this.emit('symbolLocationCreated', { symbol, type, location });
            });
        });
    }
    /**
     * @returns A clone of this SymbolUtil that is in delay mode: changes to the symbol table happened in the clone will
     * not take effect until the {@link SymbolUtil.applyDelayedEdits} method is called on that clone.
     *
     * The clone shares the same reference of the global symbol table and symbol stacks, meaning that after
     * `applyDelayedEdits` is called, the original SymbolUtil will also be modified.
     */
    clone() {
        return new SymbolUtil(this.#global, this.#eventEmitterConstructor, this.#currentContributor, true);
    }
    /**
     * Apply edits done during the delay mode.
     */
    applyDelayedEdits() {
        this._delayedOps.forEach((f) => f());
        this._delayedOps = [];
        this._inDelayMode = false;
    }
    contributeAs(contributor, fn) {
        const originalValue = this.#currentContributor;
        this.#currentContributor = contributor;
        try {
            fn();
        }
        finally {
            this.#currentContributor = originalValue;
        }
        return this;
    }
    async contributeAsAsync(contributor, fn) {
        const originalValue = this.#currentContributor;
        this.#currentContributor = contributor;
        try {
            await fn();
        }
        finally {
            this.#currentContributor = originalValue;
        }
        return this;
    }
    /**
     * @param
     * 	- `contributor` - clear symbol locations contributed by this contributor. Pass in `undefined`
     * 	to select all symbol locations that don't have a contributor.
     * 	- `uri` - clear symbol locations associated with this URI.
     * 	- `predicate` - clear symbol locations matching this predicate
     */
    clear({ uri, contributor, predicate = () => true }) {
        const getCaches = () => {
            if (contributor) {
                return this.#cache[contributor] ? [this.#cache[contributor]] : [];
            }
            else {
                return Object.values(this.#cache);
            }
        };
        const getPaths = () => {
            const caches = getCaches();
            const sets = uri
                ? caches.map((cache) => cache[uri] ?? new Set())
                : caches.map((cache) => Object.values(cache)).flat();
            return sets.map((s) => [...s]).flat().map(SymbolPath.fromString);
        };
        const getTables = () => {
            return uri ? [this.#global] : [this.#global];
        };
        const paths = getPaths();
        const tables = getTables();
        for (const table of tables) {
            for (const path of paths) {
                const { symbol } = SymbolUtil.lookupTable(table, path.category, path.path);
                if (!symbol) {
                    continue;
                }
                this.removeLocationsFromSymbol(symbol, (data) => (!uri || data.location.uri === uri)
                    && (!contributor || data.location.contributor === contributor)
                    && predicate(data));
            }
            this.trim(table);
        }
    }
    lookup(category, path, node) {
        while (node) {
            if (node.locals) {
                const result = SymbolUtil.lookupTable(node.locals, category, path);
                if (result.symbol) {
                    return result;
                }
            }
            node = node.parent;
        }
        return SymbolUtil.lookupTable(this.global, category, path);
    }
    query(doc, category, ...path) {
        const uri = SymbolUtil.toUri(doc);
        const { parentSymbol, parentMap, symbol } = this.lookup(category, path, isDocAndNode(doc) ? doc.node : undefined);
        const visible = symbol ? SymbolUtil.isVisible(symbol, uri) : true;
        return new SymbolQuery({
            category,
            doc,
            contributor: this.#currentContributor,
            map: visible ? parentMap : undefined,
            parentSymbol,
            path,
            symbol: visible ? symbol : undefined,
            util: this,
        });
    }
    getVisibleSymbols(category, uri) {
        const map = this.lookup(category, [], undefined).parentMap ?? undefined;
        return SymbolUtil.filterVisibleSymbols(uri, map);
    }
    static toUri(uri) {
        if (typeof uri === 'string') {
            return uri;
        }
        if (isDocAndNode(uri)) {
            return uri.doc.uri;
        }
        return uri.uri;
    }
    /**
     * @see {@link SymbolUtil.trimMap}
     */
    trim(table) {
        const trimSymbol = (symbol) => {
            if (!symbol) {
                return;
            }
            if (SymbolUtil.isTrimmable(symbol)) {
                delete symbol.parentMap[symbol.identifier];
                this.emit('symbolRemoved', { symbol });
                trimSymbol(symbol.parentSymbol);
            }
        };
        for (const pathString of this.#trimmableSymbols) {
            const path = SymbolPath.fromString(pathString);
            const { symbol } = SymbolUtil.lookupTable(table, path.category, path.path);
            trimSymbol(symbol);
        }
    }
    removeLocationsFromSymbol(symbol, predicate) {
        for (const type of SymbolUsageTypes) {
            if (!symbol[type]) {
                continue;
            }
            symbol[type] = symbol[type].reduce((result, location) => {
                if (predicate({ location, symbol, type })) {
                    this.emit('symbolLocationRemoved', { symbol, type, location });
                }
                else {
                    result.push(location);
                }
                return result;
            }, []);
        }
    }
    enterMap(parentSymbol, map, category, path, identifier, addition, doc, contributor) {
        let ans = map[identifier];
        if (ans) {
            this.amendSymbol(ans, addition, doc, contributor);
        }
        else {
            ans = this.createSymbol(category, parentSymbol, map, path, identifier, addition, doc, contributor);
        }
        this.emit('symbolAmended', { symbol: ans });
        return ans;
    }
    static lookupTable(table, category, path) {
        let parentMap = table[category];
        let parentSymbol;
        let symbol;
        for (let i = 0; i < path.length; i++) {
            symbol = parentMap?.[path[i]];
            if (!symbol) {
                if (i !== path.length - 1) {
                    parentSymbol = undefined;
                    parentMap = undefined;
                }
                break;
            }
            if (i === path.length - 1) {
                break;
            }
            parentSymbol = symbol;
            parentMap = symbol.members;
        }
        return { parentSymbol, parentMap, symbol };
    }
    static lookupTables(tables, category, path) {
        let parentMap;
        let parentSymbol;
        // Traverse from the last table to the first one.
        for (let i = tables.length - 1; i >= 0; i--) {
            const table = tables[i];
            const result = this.lookupTable(table, category, path);
            if (result.symbol) {
                return result;
            }
            if (!parentSymbol && !parentMap && (result.parentSymbol || result.parentMap)) {
                parentSymbol = result.parentSymbol;
                parentMap = result.parentMap;
            }
        }
        return { parentSymbol, parentMap, symbol: undefined };
    }
    createSymbol(category, parentSymbol, parentMap, path, identifier, addition, doc, contributor) {
        const ans = (parentMap[identifier] = {
            category,
            identifier,
            ...(parentSymbol ? { parentSymbol } : {}),
            parentMap,
            path,
            ...addition.data,
        });
        this.emit('symbolCreated', { symbol: ans });
        this.amendSymbolUsage(ans, addition.usage, doc, contributor);
        return ans;
    }
    amendSymbol(symbol, addition, doc, contributor) {
        this.amendSymbolMetadata(symbol, addition.data);
        this.amendSymbolUsage(symbol, addition.usage, doc, contributor);
    }
    amendSymbolMetadata(symbol, addition) {
        if (addition) {
            if ('data' in addition) {
                symbol.data = addition.data;
            }
            if ('desc' in addition) {
                symbol.desc = addition.desc;
            }
            if (addition.relations && Object.keys(addition.relations).length) {
                symbol.relations ??= {};
                for (const relationship of Object.keys(addition.relations)) {
                    symbol.relations[relationship] = addition.relations[relationship];
                }
            }
            if ('subcategory' in addition) {
                symbol.subcategory = addition.subcategory;
            }
            if ('visibility' in addition) {
                // Visibility changes are only accepted if the change wouldn't result in the
                // symbol being stored in a different symbol table.
                const inGlobalTable = (v) => v === undefined || v === 2 /* SymbolVisibility.Public */ || v === 3 /* SymbolVisibility.Restricted */;
                if (symbol.visibility === addition.visibility
                    || (inGlobalTable(symbol.visibility) && inGlobalTable(addition.visibility))) {
                    symbol.visibility = addition.visibility;
                }
                else {
                    throw new Error(`Cannot change visibility from ${symbol.visibility} to ${addition.visibility}: ${JSON.stringify(SymbolPath.fromSymbol(symbol))}`);
                }
            }
            if (addition.visibilityRestriction?.length) {
                symbol.visibilityRestriction = (symbol.visibilityRestriction ?? []).concat(addition.visibilityRestriction);
            }
        }
    }
    amendSymbolUsage(symbol, addition, doc, contributor) {
        if (addition) {
            const type = addition.type ?? 'reference';
            const arr = (symbol[type] ??= []);
            const range = Range.get((SymbolAdditionUsageWithNode.is(addition) ? addition.node : addition.range) ?? 0);
            const location = SymbolLocation.create(doc, range, addition.fullRange, contributor, {
                accessType: addition.accessType,
                skipRenaming: addition.skipRenaming,
            });
            if (!doc.uri.startsWith('file:')) {
                delete location.range;
                delete location.posRange;
                delete location.fullRange;
                delete location.fullPosRange;
            }
            arr.push(location);
            this.emit('symbolLocationCreated', { symbol, type, location });
        }
    }
    /**
     * @returns The ultimate symbol being pointed by the passed-in `symbol`'s alias.
     */
    resolveAlias(symbol) {
        return symbol?.relations?.aliasOf
            ? this.resolveAlias(this.lookup(symbol.relations.aliasOf.category, symbol.relations.aliasOf.path).symbol)
            : symbol;
    }
    static filterVisibleSymbols(uri, map = {}) {
        const ans = {};
        for (const [identifier, symbol] of Object.entries(map)) {
            if (SymbolUtil.isVisible(symbol, uri)) {
                ans[identifier] = symbol;
            }
        }
        return ans;
    }
    static isTrimmable(symbol) {
        return (!Object.keys(symbol.members ?? {}).length
            && !symbol.declaration?.length
            && !symbol.definition?.length
            && !symbol.implementation?.length
            && !symbol.reference?.length
            && !symbol.typeDefinition?.length);
    }
    static isVisible(symbol, _uri) {
        switch (symbol.visibility) {
            case 3 /* SymbolVisibility.Restricted */:
                return false; // FIXME: check with workspace root URIs.
            case 0 /* SymbolVisibility.Block */:
            case 1 /* SymbolVisibility.File */:
            case 2 /* SymbolVisibility.Public */:
            default:
                return true;
        }
    }
    /**
     * @returns If the symbol has declarations or definitions.
     */
    static isDeclared(symbol) {
        return !!(symbol?.declaration?.length || symbol?.definition?.length);
    }
    /**
     * @returns If the symbol has definitions, or declarations and implementations.
     */
    static isDefined(symbol) {
        return !!(symbol?.definition?.length
            || (symbol?.definition?.length && symbol?.implementation?.length));
    }
    /**
     * @returns If the symbol has implementations or definitions.
     */
    static isImplemented(symbol) {
        return !!(symbol?.implementation?.length || symbol?.definition?.length);
    }
    /**
     * @returns If the symbol has references.
     */
    static isReferenced(symbol) {
        return !!symbol?.reference?.length;
    }
    /**
     * @returns If the symbol has type definitions.
     */
    static isTypeDefined(symbol) {
        return !!symbol?.typeDefinition?.length;
    }
    /**
     * @throws If the symbol does not have any declarations or definitions.
     */
    static getDeclaredLocation(symbol) {
        return (symbol.declaration?.[0] ?? symbol.definition?.[0] ?? (() => {
            throw new Error(`Cannot get declared location of ${JSON.stringify(SymbolPath.fromSymbol(symbol))}`);
        })());
    }
    static forEachSymbolInMap(map, fn) {
        for (const symbol of Object.values(map)) {
            fn(symbol);
            if (symbol.members) {
                this.forEachSymbolInMap(symbol.members, fn);
            }
        }
    }
    static forEachSymbol(table, fn) {
        for (const map of Object.values(table)) {
            this.forEachSymbolInMap(map, fn);
        }
    }
    static forEachLocationOfSymbol(symbol, fn) {
        for (const type of SymbolUsageTypes) {
            symbol[type]?.forEach((location) => fn({ type, location }));
        }
    }
    static isVisibilityInGlobal(v) {
        return (v === undefined || v === 2 /* SymbolVisibility.Public */ || v === 3 /* SymbolVisibility.Restricted */);
    }
    static areVisibilitiesCompatible(v1, v2) {
        return ((this.isVisibilityInGlobal(v1) && this.isVisibilityInGlobal(v2))
            || (v1 === 0 /* SymbolVisibility.Block */ && v2 === 0 /* SymbolVisibility.Block */)
            || (v1 === 1 /* SymbolVisibility.File */ && v2 === 1 /* SymbolVisibility.File */));
    }
}
__decorate([
    DelayModeSupport()
], SymbolUtil.prototype, "clear", null);
__decorate([
    DelayModeSupport()
], SymbolUtil.prototype, "trim", null);
__decorate([
    DelayModeSupport()
], SymbolUtil.prototype, "removeLocationsFromSymbol", null);
var SymbolAdditionUsageWithRange;
(function (SymbolAdditionUsageWithRange) {
    /* istanbul ignore next */
    function is(usage) {
        return !!usage?.range;
    }
    SymbolAdditionUsageWithRange.is = is;
})(SymbolAdditionUsageWithRange || (SymbolAdditionUsageWithRange = {}));
var SymbolAdditionUsageWithNode;
(function (SymbolAdditionUsageWithNode) {
    /* istanbul ignore next */
    function is(usage) {
        return !!usage?.node;
    }
    SymbolAdditionUsageWithNode.is = is;
})(SymbolAdditionUsageWithNode || (SymbolAdditionUsageWithNode = {}));
/* istanbul ignore next */
export class SymbolQuery {
    category;
    path;
    #doc;
    #node;
    /**
     * If only a string URI (instead of a {@link TextDocument}) is provided when constructing this class.
     *
     * If this is `true`, {@link SymbolAdditionUsageWithRange.range} is ignored and treated as `[0, 0)` when entering symbols through this class.
     */
    #createdWithUri;
    #currentContributor;
    #hasTriggeredIf = false;
    /**
     * The map where the queried symbol is stored. `undefined` if the map hasn't been created yet.
     */
    #map;
    #parentSymbol;
    /**
     * The queried symbol. `undefined` if the symbol hasn't been created yet.
     */
    #symbol;
    /**
     * The {@link SymbolUtil} where this query was created.
     */
    util;
    get symbol() {
        return this.#symbol;
    }
    get visibleMembers() {
        return SymbolUtil.filterVisibleSymbols(this.#doc.uri, this.path.length === 0 ? this.#map : this.#symbol?.members);
    }
    constructor({ category, contributor, doc, map, parentSymbol, path, symbol, util }) {
        this.category = category;
        this.path = path;
        if (typeof doc === 'string') {
            doc = TextDocument.create(doc, '', 0, '');
            this.#createdWithUri = true;
        }
        else if (isDocAndNode(doc)) {
            this.#node = doc.node;
            doc = doc.doc;
        }
        this.#doc = doc;
        this.#currentContributor = contributor;
        this.#map = map;
        this.#parentSymbol = parentSymbol;
        this.#symbol = symbol;
        this.util = util;
    }
    heyGimmeDaSymbol() {
        return this.#symbol;
    }
    getData(predicate) {
        const data = this.#symbol?.data;
        return predicate(data) ? data : undefined;
    }
    with(fn) {
        fn(this);
        return this;
    }
    if(predicate, fn) {
        if (predicate.call(this, this.#symbol, this)) {
            fn.call(this, this.#symbol, this);
            this.#hasTriggeredIf = true;
        }
        return this;
    }
    /**
     * Calls `fn` if the queried symbol does not exist.
     */
    ifUnknown(fn) {
        return this.if((s) => s === undefined, fn);
    }
    /**
     * Calls `fn` if the queried symbol exists (i.e. has any of declarations/definitions/implementations/references/typeDefinitions).
     */
    ifKnown(fn) {
        return this.if((s) => s !== undefined, fn);
    }
    /**
     * Calls `fn` if the queried symbol has declarations or definitions.
     */
    ifDeclared(fn) {
        return this.if((s) => SymbolUtil.isDeclared(s), fn);
    }
    /**
     * Calls `fn` if the queried symbol has definitions, or both declarations and implementations.
     */
    ifDefined(fn) {
        return this.if(SymbolUtil.isDefined, fn);
    }
    /**
     * Calls `fn` if the queried symbol has implementations or definitions.
     */
    ifImplemented(fn) {
        return this.if(SymbolUtil.isImplemented, fn);
    }
    /**
     * Calls `fn` if the queried symbol has references.
     */
    ifReferenced(fn) {
        return this.if(SymbolUtil.isReferenced, fn);
    }
    /**
     * Calls `fn` if the queried symbol has type definitions.
     */
    ifTypeDefined(fn) {
        return this.if(SymbolUtil.isTypeDefined, fn);
    }
    /**
     * Calls `fn` if none of the former `if` conditions are met.
     */
    else(fn) {
        if (!this.#hasTriggeredIf) {
            fn.call(this, this.#symbol, this);
        }
        return this;
    }
    /**
     * Enters the queried symbol if none of the former `if` conditions are met.
     */
    elseEnter(symbol) {
        return this.else(() => this.enter(symbol));
    }
    /**
     * Resolves the queried symbol if it is an alias and if none of the former `if` conditions are met.
     *
     * @throws If the current symbol points to an non-existent symbol.
     */
    elseResolveAlias() {
        return this.else(() => this.resolveAlias());
    }
    _enter(addition) {
        /**
         * Get a proper visibility from the addition:
         * * If the visibility is specified, use it.
         * * If the visibility is `undefined`, use the visibility of the symbol, or `Public` if unapplicable.
         */
        const getAdditionVisibility = (addition) => {
            return (addition.data?.visibility ?? this.symbol?.visibility ?? 2 /* SymbolVisibility.Public */);
        };
        const getMap = (addition) => {
            const additionVisibility = getAdditionVisibility(addition);
            if (this.#map
                && SymbolUtil.areVisibilitiesCompatible(additionVisibility, this.#symbol?.visibility)) {
                return this.#map;
            }
            if (this.path.length > 1) {
                if (this.#parentSymbol) {
                    if (!SymbolUtil.areVisibilitiesCompatible(additionVisibility, this.#parentSymbol.visibility)) {
                        throw new Error(`Cannot enter member “${this.getPath()}” of ${SymbolFormatter.stringifyVisibility(additionVisibility)} visibility to parent of ${SymbolFormatter.stringifyVisibility(this.#parentSymbol.visibility)} visibility`);
                    }
                    return (this.#parentSymbol.members ??= {});
                }
            }
            else {
                let table;
                if (SymbolUtil.isVisibilityInGlobal(additionVisibility)) {
                    table = this.util.global;
                }
                else if (additionVisibility === 1 /* SymbolVisibility.File */) {
                    if (!this.#node) {
                        throw new Error(`Cannot enter “${this.getPath()}” with ${SymbolFormatter.stringifyVisibility(additionVisibility)} visibility as no node is supplied`);
                    }
                    let node = this.#node;
                    while (node) {
                        if (node.type === 'file') {
                            table = node.locals;
                            break;
                        }
                        node = node.parent;
                    }
                    if (!table) {
                        throw new Error(`Cannot enter “${this.getPath()}” with ${SymbolFormatter.stringifyVisibility(additionVisibility)} visibility as no file node is supplied`);
                    }
                }
                else {
                    if (!this.#node) {
                        throw new Error(`Cannot enter “${this.getPath()}” with ${SymbolFormatter.stringifyVisibility(additionVisibility)} visibility as no node is supplied`);
                    }
                    let node = this.#node;
                    while (node) {
                        if (node.locals) {
                            table = node.locals;
                            break;
                        }
                        node = node.parent;
                    }
                    if (!table) {
                        throw new Error(`Cannot enter “${this.getPath()}” with ${SymbolFormatter.stringifyVisibility(additionVisibility)} visibility as no node with locals is supplied`);
                    }
                }
                // TODO: Move part of symbol from global to table.
                return (table[this.category] ??= {});
            }
            throw new Error(`Cannot create the symbol map for “${this.getPath()}”`);
        };
        // Treat `usage.range` as `[0, 0)` if this class was constructed with a string URI (instead of a `TextDocument`).
        if (this.#createdWithUri && SymbolAdditionUsageWithRange.is(addition.usage)) {
            addition.usage.range = Range.create(0, 0);
        }
        this.#map = getMap(addition);
        this.#symbol = this.util.enterMap(this.#parentSymbol, this.#map, this.category, this.path, this.path[this.path.length - 1], addition, this.#doc, this.#currentContributor);
        if (addition.usage?.node) {
            addition.usage.node.symbol = this.#symbol;
        }
    }
    /**
     * Enters the queried symbol.
     *
     * @throws If the parent of this symbol doesn't exist either.
     */
    enter(addition) {
        this._enter(addition);
        return this;
    }
    /**
     * Amends the queried symbol if the queried symbol exists (i.e. has any of declarations/definitions/implementations/references/typeDefinitions) and is visible at the current scope.
     *
     * This is equivalent to calling
     * ```typescript
     * query.ifKnown(function () {
     * 	this.enter(symbol)
     * })
     * ```
     *
     * Therefore, if the symbol is successfully amended, `elseX` methods afterwards will **not** be executed.
     */
    amend(symbol) {
        return this.ifKnown(() => this.enter(symbol));
    }
    /**
     * Resolves this symbol if it exists and is an alias.
     *
     * @throws If the current symbol points to an non-existent symbol. The state of this object will not be changed
     * after the error is thrown.
     */
    resolveAlias() {
        if (this.#symbol) {
            const result = this.util.resolveAlias(this.#symbol);
            if (!result) {
                throw new Error('The current symbol points to an non-existent symbol.');
            }
            this.#symbol = result;
            this.#map = result.parentMap;
            this.#parentSymbol = result.parentSymbol;
            this.path = result.path;
        }
        return this;
    }
    member() {
        // Handle overloads.
        let doc, identifier, fn;
        if (arguments.length === 2) {
            // Ensure the member query result will not unknowingly have a dummy TextDocument passed down from this class.
            doc = this.#createdWithUri ? this.#doc.uri : this.#doc;
            identifier = arguments[0];
            fn = arguments[1];
        }
        else {
            doc = arguments[0];
            identifier = arguments[1];
            fn = arguments[2];
        }
        if (this.#symbol === undefined) {
            throw new Error(`Tried to query member symbol “${identifier}” from an undefined symbol (path “${this.path.join('.')}”)`);
        }
        const memberDoc = typeof doc === 'string' && doc === this.#doc.uri && !this.#createdWithUri
            ? this.#doc
            : doc;
        const memberMap = this.#symbol.members;
        const memberSymbol = memberMap?.[identifier];
        const memberQueryResult = new SymbolQuery({
            category: this.category,
            doc: memberDoc,
            contributor: this.#currentContributor,
            map: memberMap,
            parentSymbol: this.#symbol,
            path: [...this.path, identifier],
            symbol: memberSymbol,
            util: this.util,
        });
        fn(memberQueryResult);
        return this;
    }
    /**
     * Do something with this query on each value in a given iterable. The query itself will be included
     * in the callback function as the second parameter.
     */
    onEach(values, fn) {
        for (const value of values) {
            fn.call(this, value, this);
        }
        return this;
    }
    forEachMember(fn) {
        return this.onEach(Object.keys(this.visibleMembers), (identifier) => this.member(identifier, (query) => fn(identifier, query)));
    }
    getPath() {
        return `${this.category}.${this.path.join('/')}`;
    }
}
__decorate([
    DelayModeSupport((self) => self.util)
], SymbolQuery.prototype, "_enter", null);
/* istanbul ignore next */
/**
 * A series of methods for converting symbol structures to human-readable outputs. Mostly for debug purposes.
 */
export var SymbolFormatter;
(function (SymbolFormatter) {
    const IndentChar = '+ ';
    function assertEqual(a, b) {
        if (a !== b) {
            throw new Error(`Assertion error: ${a} !== ${b}`);
        }
    }
    function stringifySymbolStack(stack) {
        return stack.map((table) => stringifySymbolTable(table)).join('\n------------\n');
    }
    SymbolFormatter.stringifySymbolStack = stringifySymbolStack;
    function stringifySymbolTable(table, indent = '') {
        const ans = [];
        for (const category of Object.keys(table)) {
            const map = table[category];
            ans.push([category, stringifySymbolMap(map, `${indent}${IndentChar}`)]);
        }
        return (ans.map((v) => `CATEGORY ${v[0]}\n${v[1]}`).join(`\n${indent}------------\n`)
            || 'EMPTY TABLE');
    }
    SymbolFormatter.stringifySymbolTable = stringifySymbolTable;
    function stringifySymbolMap(map, indent = '') {
        if (!map) {
            return 'undefined';
        }
        const ans = [];
        for (const identifier of Object.keys(map)) {
            const symbol = map[identifier];
            assertEqual(identifier, symbol.identifier);
            ans.push(stringifySymbol(symbol, indent));
        }
        return ans.join(`\n${indent}------------\n`);
    }
    SymbolFormatter.stringifySymbolMap = stringifySymbolMap;
    function stringifySymbol(symbol, indent = '') {
        if (!symbol) {
            return 'undefined';
        }
        const ans = [];
        assertEqual(symbol.path[symbol.path.length - 1], symbol.identifier);
        ans.push(`SYMBOL ${symbol.path.join('.')}`
            + ` {${symbol.category}${symbol.subcategory ? ` (${symbol.subcategory})` : ''}}`
            + ` [${stringifyVisibility(symbol.visibility, symbol.visibilityRestriction)}]`);
        if (symbol.data) {
            ans.push(`${IndentChar}data: ${JSON.stringify(symbol.data)}`);
        }
        if (symbol.desc) {
            ans.push(`${IndentChar}description: ${symbol.desc}`);
        }
        for (const type of SymbolUsageTypes) {
            if (symbol[type]) {
                ans.push(`${IndentChar}${type}:\n${symbol[type].map((v) => `${indent}${IndentChar.repeat(2)}${JSON.stringify(v)}`)
                    .join(`\n${indent}${IndentChar.repeat(2)}------------\n`)}`);
            }
        }
        if (symbol.relations) {
            ans.push(`${IndentChar}relations: ${JSON.stringify(symbol.relations)}`);
        }
        if (symbol.members) {
            ans.push(`${IndentChar}members:\n${stringifySymbolMap(symbol.members, `${indent}${IndentChar.repeat(2)}`)}`);
        }
        return ans.map((v) => `${indent}${v}`).join('\n');
    }
    SymbolFormatter.stringifySymbol = stringifySymbol;
    function stringifyVisibility(visibility, visibilityRestriction) {
        let stringVisibility;
        // Const enums cannot be indexed even if `--preserveConstEnums` is on: https://github.com/microsoft/TypeScript/issues/31353
        switch (visibility) {
            case 0 /* SymbolVisibility.Block */:
                stringVisibility = 'Block';
                break;
            case 1 /* SymbolVisibility.File */:
                stringVisibility = 'File';
                break;
            case 3 /* SymbolVisibility.Restricted */:
                stringVisibility = 'Restricted';
                break;
            default:
                stringVisibility = 'Public';
                break;
        }
        return `${stringVisibility}${visibilityRestriction ? ` ${visibilityRestriction.map((v) => `“${v}”`).join(', ')}` : ''}`;
    }
    SymbolFormatter.stringifyVisibility = stringifyVisibility;
    function stringifyLookupResult(result) {
        return `parentSymbol:
${stringifySymbol(result.parentSymbol, IndentChar)}
parentMap:
${stringifySymbolMap(result.parentMap, IndentChar)}
symbol:
${stringifySymbol(result.symbol, IndentChar)}`;
    }
    SymbolFormatter.stringifyLookupResult = stringifyLookupResult;
})(SymbolFormatter || (SymbolFormatter = {}));
/**
 * Make a method support delay mode: if the {@link SymbolUtil} is in delay mode, the actual invocation of the method will be
 * stored to the {@link SymbolUtil._delayedOps} array.
 *
 * The decorated method MUST have return type `void`.
 */
function DelayModeSupport(getUtil = (self) => self) {
    return (_target, _key, descripter) => {
        const decoratedMethod = descripter.value;
        // The `function` syntax is used to preserve `this` context from the decorated method.
        descripter.value = function (...args) {
            const util = getUtil(this);
            if (util._inDelayMode) {
                util._delayedOps.push(decoratedMethod.bind(this, ...args));
            }
            else {
                decoratedMethod.apply(this, args);
            }
        };
        return descripter;
    };
}
function isDocAndNode(doc) {
    return !!doc.doc;
}
//# sourceMappingURL=SymbolUtil.js.map