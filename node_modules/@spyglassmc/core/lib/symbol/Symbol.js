import rfdc from 'rfdc';
import { isIterable } from '../common/index.js';
import { Location, PositionRange, Range } from '../source/index.js';
// #region Mcdoc Categories
export const McdocCategories = Object.freeze(['mcdoc', 'mcdoc/dispatcher']);
// #endregion
// #region Registry Categories
// Data in `java-edition/src/binder/index.ts` may need to be updated when this section is changed.
export const RegistryCategories = Object.freeze([
    'activity',
    'armor_material', // Removed
    'attribute',
    'attribute_type',
    'block',
    'block_entity_type',
    'block_predicate_type',
    'block_type',
    'chunk_status',
    'command_argument_type',
    'consume_effect_type',
    'creative_mode_tab',
    'custom_stat',
    'data_component_predicate_type',
    'data_component_type',
    'debug_subscription',
    'decorated_pot_pattern',
    'decorated_pot_patterns', // Removed
    'dialog_action_type',
    'dialog_body_type',
    'dialog_type',
    'enchantment_effect_component_type',
    'enchantment_entity_effect_type',
    'enchantment_level_based_value_type',
    'enchantment_location_based_effect_type',
    'enchantment_provider_type',
    'enchantment_value_effect_type',
    'entity_sub_predicate_type',
    'entity_type',
    'environment_attribute',
    'float_provider_type',
    'fluid',
    'game_event',
    'game_rule',
    'height_provider_type',
    'incoming_rpc_methods',
    'input_control_type',
    'instrument',
    'int_provider_type',
    'item',
    'item_sub_predicate_type', // Removed
    'loot_condition_type',
    'loot_function_type',
    'loot_nbt_provider_type',
    'loot_number_provider_type',
    'loot_pool_entry_type',
    'loot_score_provider_type',
    'map_decoration_type',
    'memory_module_type',
    'menu',
    'mob_effect',
    'motive', // Removed
    'number_format_type',
    'outgoing_rpc_methods',
    'particle_type',
    'permission_check_type',
    'permission_type',
    'point_of_interest_type',
    'pos_rule_test',
    'position_source_type',
    'potion',
    'recipe_book_category',
    'recipe_display',
    'recipe_serializer',
    'recipe_type',
    'rule_block_entity_modifier',
    'rule_test',
    'schedule', // Removed
    'sensor_type',
    'slot_display',
    'slot_source_type',
    'sound_event',
    'spawn_condition_type',
    'stat_type',
    'test_environment_definition_type',
    'test_function',
    'test_instance_type',
    'trigger_type',
    'ticket_type',
    'villager_profession',
    'villager_type',
    'worldgen/biome_source',
    'worldgen/block_placer_type', // Removed
    'worldgen/block_state_provider_type',
    'worldgen/carver',
    'worldgen/chunk_generator',
    'worldgen/decorator', // Removed
    'worldgen/density_function_type',
    'worldgen/feature',
    'worldgen/feature_size_type',
    'worldgen/foliage_placer_type',
    'worldgen/material_condition',
    'worldgen/material_rule',
    'worldgen/placement_modifier_type',
    'worldgen/pool_alias_binding',
    'worldgen/root_placer_type',
    'worldgen/structure_feature', // Removed
    'worldgen/structure_piece',
    'worldgen/structure_placement',
    'worldgen/structure_pool_element',
    'worldgen/structure_processor',
    'worldgen/structure_type',
    'worldgen/surface_builder', // Removed
    'worldgen/tree_decorator_type',
    'worldgen/trunk_placer_type',
]);
// #endregion
// #region Data Pack Categories
export const NormalFileCategories = Object.freeze([
    'advancement',
    'banner_pattern',
    'cat_variant',
    'chat_type',
    'chicken_variant',
    'cow_variant',
    'damage_type',
    'dialog',
    'dimension',
    'dimension_type',
    'enchantment',
    'enchantment_provider',
    'frog_variant',
    'function',
    'instrument',
    'item_modifier',
    'jukebox_song',
    'loot_table',
    'painting_variant',
    'pig_variant',
    'predicate',
    'recipe',
    'structure',
    'test_environment',
    'test_instance',
    'timeline',
    'trade_set',
    'trial_spawner',
    'trim_material',
    'trim_pattern',
    'villager_trade',
    'wolf_sound_variant',
    'wolf_variant',
    'world_clock',
    'zombie_nautilus_variant',
]);
export const WorldgenFileCategories = Object.freeze([
    'worldgen/biome',
    'worldgen/configured_carver',
    'worldgen/configured_feature',
    'worldgen/configured_structure_feature',
    'worldgen/configured_surface_builder',
    'worldgen/density_function',
    'worldgen/flat_level_generator_preset',
    'worldgen/multi_noise_biome_source_parameter_list',
    'worldgen/noise',
    'worldgen/noise_settings',
    'worldgen/placed_feature',
    'worldgen/processor_list',
    'worldgen/structure',
    'worldgen/structure_set',
    'worldgen/template_pool',
    'worldgen/world_preset',
]);
export const TaggableResourceLocationCategories = Object.freeze([...NormalFileCategories, ...RegistryCategories, ...WorldgenFileCategories]);
export var TaggableResourceLocationCategory;
(function (TaggableResourceLocationCategory) {
    function is(category) {
        return TaggableResourceLocationCategories.includes(category);
    }
    TaggableResourceLocationCategory.is = is;
})(TaggableResourceLocationCategory || (TaggableResourceLocationCategory = {}));
export const TagFileCategories = Object.freeze(TaggableResourceLocationCategories.map((key) => `tag/${key}`));
export const DataFileCategories = Object.freeze([...NormalFileCategories, ...TagFileCategories, ...WorldgenFileCategories]);
export const DataMiscCategories = Object.freeze([
    'attribute_modifier',
    'bossbar',
    'jigsaw_block_name',
    'random_sequence',
    'storage',
    'stopwatch',
]);
export const DatapackCategories = Object.freeze([
    'attribute_modifier_uuid',
    'objective',
    'player_uuid',
    'score_holder',
    'tag',
    'team',
    ...DataFileCategories,
    ...DataMiscCategories,
]);
// #endregion
// #region Resource Pack Categories
export const AssetsFileCategories = Object.freeze([
    'atlas',
    'block_definition', // blockstates
    'equipment',
    'font',
    'font/ttf',
    'font/otf',
    'font/unihex',
    'gpu_warnlist',
    'item_definition', // items
    'lang',
    'lang/deprecated',
    'model',
    'particle',
    'post_effect',
    'regional_compliancies',
    'shader',
    'shader/fragment',
    'shader/vertex',
    'sound',
    'sounds', // sounds.json
    'texture',
    'texture_meta', // *.png.mcmeta
    'waypoint_style',
]);
export const AssetsMiscCategories = Object.freeze([
    'texture_slot',
    'shader_target',
    'translation_key',
]);
export const ResourcepackCategories = Object.freeze([
    ...AssetsMiscCategories,
    ...AssetsFileCategories,
]);
// #endregion
export const FileCategories = Object.freeze([...DataFileCategories, ...AssetsFileCategories]);
export const AllCategories = Object.freeze([
    ...DatapackCategories,
    ...ResourcepackCategories,
    ...McdocCategories,
    ...RegistryCategories,
]);
export const ResourceLocationCategories = Object.freeze([
    'mcdoc/dispatcher',
    ...DataMiscCategories,
    ...AssetsMiscCategories,
    ...FileCategories,
    ...RegistryCategories,
]);
export var ResourceLocationCategory;
(function (ResourceLocationCategory) {
    function is(category) {
        return ResourceLocationCategories.includes(category);
    }
    ResourceLocationCategory.is = is;
})(ResourceLocationCategory || (ResourceLocationCategory = {}));
export var SymbolPath;
(function (SymbolPath) {
    function fromSymbol(symbol) {
        return symbol ? { category: symbol.category, path: symbol.path } : undefined;
    }
    SymbolPath.fromSymbol = fromSymbol;
    /**
     * Equivalent {@link SymbolPath}s will always be serialized into the same string value.
     */
    function toString(path) {
        return JSON.stringify({ category: path.category, path: path.path });
    }
    SymbolPath.toString = toString;
    function fromString(value) {
        return JSON.parse(value);
    }
    SymbolPath.fromString = fromString;
})(SymbolPath || (SymbolPath = {}));
export class SymbolPathCollector {
    #set = new Set();
    add(path) {
        if (!path) {
            return;
        }
        this.#set.add(SymbolPath.toString(path));
    }
    has(path) {
        return this.#set.has(SymbolPath.toString(path));
    }
    collect() {
        return [...this.#set].map(SymbolPath.fromString);
    }
}
export const SymbolUsageTypes = Object.freeze(['definition', 'declaration', 'implementation', 'reference', 'typeDefinition']);
export var SymbolUsageType;
(function (SymbolUsageType) {
    function is(value) {
        return SymbolUsageTypes.includes(value);
    }
    SymbolUsageType.is = is;
})(SymbolUsageType || (SymbolUsageType = {}));
export var Symbol;
(function (Symbol) {
    function get(table, category, ...path) {
        if (isIterable(table)) {
            for (const t of table) {
                const result = get(t, category, ...path);
                if (result) {
                    return result;
                }
            }
            return undefined;
        }
        const map = table[category];
        for (const p of path) {
        }
        return undefined;
    }
    Symbol.get = get;
})(Symbol || (Symbol = {}));
export var SymbolLocation;
(function (SymbolLocation) {
    /* istanbul ignore next */
    function create(doc, range, fullRange, contributor, additional) {
        return {
            ...Location.create(doc, range),
            ...(fullRange
                ? { fullRange: Range.get(fullRange), fullPosRange: PositionRange.from(fullRange, doc) }
                : {}),
            ...(contributor ? { contributor } : {}),
            ...(additional ? additional : {}),
        };
    }
    SymbolLocation.create = create;
})(SymbolLocation || (SymbolLocation = {}));
export var SymbolTable;
(function (SymbolTable) {
    /**
     * The passed-in parameter `table` won't be mutated.
     *
     * @returns An identical symbol table where each Symbol's `parentMap` and `parentSymbol` properties
     * are set properly.
     */
    function link(table) {
        const linkSymbol = (symbol, parentMap, parentSymbol, category, path) => {
            symbol.category = category;
            symbol.identifier = path[path.length - 1];
            symbol.path = path;
            symbol.parentMap = parentMap;
            if (parentSymbol) {
                symbol.parentSymbol = parentSymbol;
            }
            if (symbol.members) {
                linkSymbolMap(symbol.members, symbol, category, path);
            }
        };
        const linkSymbolMap = (map, parentSymbol, category, path) => {
            for (const [identifier, childSymbol] of Object.entries(map)) {
                linkSymbol(childSymbol, map, parentSymbol, category, [...path, identifier]);
            }
        };
        const ans = rfdc()(table);
        for (const [category, map] of Object.entries(ans)) {
            linkSymbolMap(map, undefined, category, []);
        }
        return ans;
    }
    SymbolTable.link = link;
    /**
     * The passed-in parameter `table` won't be mutated.
     *
     * @returns An identical symbol table where each Symbol's `parentMap` and `parentSymbol` properties
     * are deleted.
     */
    function unlink(table) {
        const unlinkSymbol = (symbol) => {
            delete symbol.category;
            delete symbol.identifier;
            delete symbol.parentMap;
            delete symbol.parentSymbol;
            delete symbol.path;
            if (symbol.members) {
                unlinkSymbolMap(symbol.members);
            }
        };
        const unlinkSymbolMap = (map) => {
            for (const childSymbol of Object.values(map)) {
                unlinkSymbol(childSymbol);
            }
        };
        const ans = rfdc({ circles: true })(table);
        for (const map of Object.values(ans)) {
            unlinkSymbolMap(map);
        }
        return ans;
    }
    SymbolTable.unlink = unlink;
    /**
     * @returns A serialized string representation of this symbol table. It can be turned back into
     * a symbol table through the {@link deserialize} method.
     */
    function serialize(table) {
        return JSON.stringify(unlink(table));
    }
    SymbolTable.serialize = serialize;
    /**
     * @returns The symbol table represented by the string returned by the {@link serialize} method.
     */
    function deserialize(json) {
        return link(JSON.parse(json));
    }
    SymbolTable.deserialize = deserialize;
})(SymbolTable || (SymbolTable = {}));
// interface SymbolEvent {
// 	symbol: Symbol,
// }
// interface SymbolLocationEvent extends SymbolEvent {
// 	type: SymbolUsageType,
// 	location: SymbolLocation,
// }
// export class CachedSymbolTable extends TypedEmitter<{
// 	symbolCreated: (e: SymbolEvent) => unknown,
// 	symbolAmended: (e: SymbolEvent) => unknown,
// 	symbolRemoved: (e: SymbolEvent) => unknown,
// 	symbolLocationCreated: (e: SymbolLocationEvent) => unknown,
// 	symbolLocationRemoved: (e: SymbolLocationEvent) => unknown,
// }> {
// 	constructor(public readonly table: SymbolTable) {
// 		super()
// 	}
// }
//# sourceMappingURL=Symbol.js.map