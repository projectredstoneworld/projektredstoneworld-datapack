import type { Parser } from '../parser/index.js';
import type { ColorTokenType } from '../processor/index.js';
import type { IndexMap, RangeLike } from '../source/index.js';
import type { AstNode } from './AstNode.js';
export declare const EscapeChars: readonly ["\"", "'", "\\", "b", "f", "n", "r", "s", "t"];
export type EscapeChar = (typeof EscapeChars)[number];
export declare namespace EscapeChar {
    function is(expected: EscapeChar[] | undefined, c: string): c is EscapeChar;
}
export declare const EscapeTable: Map<"\"" | "'" | "\\" | "b" | "f" | "n" | "r" | "s" | "t", string>;
export type Quote = "'" | '"';
export interface StringOptions {
    colorTokenType?: ColorTokenType;
    escapable?: {
        /**
         * A list of characters that can be escaped. The current quote of the string and backslash (`\`)
         * will be added to this list automatically.
         */
        characters?: EscapeChar[];
        /**
         * Whether escapes like `\u####` where #### is a hexdecimal numeral are allowed.
         */
        unicode?: boolean;
        /**
         * Whether unknown characters can be escaped, which would just result in the character itself.
         */
        allowUnknown?: boolean;
    } | false;
    /**
     * A list of characters that can serve as a quotation mark.
     */
    quotes?: Quote[];
    /**
     * Whether this string could be an unquoted string. If yes, specify the list of allowed/disallowed characters that
     * the string can contain. Otherwise set this to `false`.
     */
    unquotable?: {
        allowEmpty?: boolean;
        allowList?: Set<string>;
        blockList?: Set<string>;
    } | false;
    /**
     * An optional object describing the content of the string.
     */
    value?: {
        parser: Parser;
        type: AstNode['type'];
    };
}
export type QuoteTypeConfig = 'always double' | 'always single' | 'prefer double' | 'prefer single';
export interface StringBaseNode extends AstNode {
    readonly options: StringOptions;
    quote?: Quote;
    value: string;
    readonly valueMap: IndexMap;
}
export declare namespace StringBaseNode {
    function is(obj: object | undefined): obj is StringBaseNode;
}
export interface StringNode extends StringBaseNode {
    readonly type: 'string';
}
export declare namespace StringNode {
    function is(obj: object | undefined): obj is StringNode;
    function mock(range: RangeLike, options: StringOptions): StringNode;
}
//# sourceMappingURL=StringNode.d.ts.map