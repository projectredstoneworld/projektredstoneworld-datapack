import { localize } from '@spyglassmc/locales';
import { ErrorSeverity, Range, Source } from '../source/index.js';
import { Failure } from './Parser.js';
const fallbackOnOutOfRange = (ans, _src, ctx, options) => {
    ctx.err.report(localize('expected', localize('float.between', options.min ?? '-∞', options.max ?? '+∞')), ans, ErrorSeverity.Error);
};
export function float(options) {
    return (src, ctx) => {
        const ans = { type: 'float', range: Range.create(src), value: 0 };
        if (src.peek() === '-' || src.peek() === '+') {
            src.skip();
        }
        while (src.canRead() && Source.isDigit(src.peek())) {
            src.skip();
        }
        if (src.trySkip('.')) {
            while (src.canRead() && Source.isDigit(src.peek())) {
                src.skip();
            }
        }
        if (src.peek().toLowerCase() === 'e') {
            src.skip();
            if (src.peek() === '-' || src.peek() === '+') {
                src.skip();
            }
            while (src.canRead() && Source.isDigit(src.peek())) {
                src.skip();
            }
        }
        ans.range.end = src.cursor;
        const raw = src.sliceToCursor(ans.range.start);
        ans.value = parseFloat(raw) || 0;
        if (!raw) {
            if (options.failsOnEmpty) {
                return Failure;
            }
            ctx.err.report(localize('expected', localize('float')), ans);
        }
        else if (!options.pattern.test(raw)) {
            ctx.err.report(localize('parser.float.illegal', options.pattern), ans);
        }
        else if ((options.min && ans.value < options.min) || (options.max && ans.value > options.max)) {
            const onOutOfRange = options.onOutOfRange ?? fallbackOnOutOfRange;
            onOutOfRange(ans, src, ctx, options);
        }
        return ans;
    };
}
//# sourceMappingURL=float.js.map