import { localize } from '@spyglassmc/locales';
import { SequenceUtil, SequenceUtilDiscriminator } from '../node/index.js';
import { ErrorReporter } from '../service/index.js';
import { Range, Source } from '../source/index.js';
import { Failure } from './Parser.js';
export function attempt(parser, src, ctx) {
    const tmpSrc = src.clone();
    const tmpCtx = { ...ctx, err: new ErrorReporter(ctx.err.source) };
    const result = parser(tmpSrc, tmpCtx);
    return {
        result,
        endCursor: tmpSrc.cursor,
        errorAmount: tmpCtx.err.errors.length,
        updateSrcAndCtx: () => {
            src.innerCursor = tmpSrc.innerCursor;
            ctx.err.absorb(tmpCtx.err);
        },
    };
}
export function sequence(parsers, parseGap) {
    return (src, ctx) => {
        const ans = {
            [SequenceUtilDiscriminator]: true,
            children: [],
            range: Range.create(src),
        };
        for (const [i, p] of parsers.entries()) {
            const parser = typeof p === 'function' ? p : p.get(ans);
            if (parser === undefined) {
                continue;
            }
            if (i > 0 && parseGap) {
                ans.children.push(...parseGap(src, ctx));
            }
            const result = parser(src, ctx);
            if (result === Failure) {
                return Failure;
            }
            else if (result === undefined) {
                continue;
            }
            else if (SequenceUtil.is(result)) {
                ans.children.push(...result.children);
            }
            else {
                ans.children.push(result);
            }
        }
        ans.range.end = src.cursor;
        return ans;
    };
}
export function repeat(parser, parseGap) {
    return (src, ctx) => {
        const ans = {
            [SequenceUtilDiscriminator]: true,
            children: [],
            range: Range.create(src),
        };
        while (src.canRead()) {
            if (parseGap) {
                ans.children.push(...parseGap(src, ctx));
            }
            const { result, updateSrcAndCtx } = attempt(parser, src, ctx);
            if (result === Failure) {
                break;
            }
            updateSrcAndCtx();
            if (SequenceUtil.is(result)) {
                ans.children.push(...result.children);
            }
            else {
                ans.children.push(result);
            }
        }
        ans.range.end = src.cursor;
        return ans;
    };
}
export function any(parsers, out) {
    return (src, ctx) => {
        const results = parsers.map((parser, i) => ({ attempt: attempt(parser, src, ctx), index: i })).filter(({ attempt }) => attempt.result !== Failure).sort((a, b) => b.attempt.endCursor - a.attempt.endCursor || a.attempt.errorAmount - b.attempt.errorAmount);
        if (results.length === 0) {
            if (out) {
                out.index = -1;
            }
            return Failure;
        }
        results[0].attempt.updateSrcAndCtx();
        if (out) {
            out.index = results[0].index;
        }
        return results[0].attempt.result;
    };
}
/**
 * @returns A parser that fails when the passed-in parser didn't move the cursor at all.
 */
export function failOnEmpty(parser) {
    return (src, ctx) => {
        const start = src.cursor;
        const { endCursor, updateSrcAndCtx, result } = attempt(parser, src, ctx);
        if (endCursor - start > 0) {
            updateSrcAndCtx();
            return result;
        }
        return Failure;
    };
}
/**
 * @returns A parser that fails when the passed-in parser produced any errors.
 */
export function failOnError(parser) {
    return (src, ctx) => {
        const start = src.cursor;
        const { errorAmount, updateSrcAndCtx, result } = attempt(parser, src, ctx);
        if (!errorAmount) {
            updateSrcAndCtx();
            return result;
        }
        return Failure;
    };
}
export function optional(parser) {
    return ((src, ctx) => {
        const { result, updateSrcAndCtx } = attempt(parser, src, ctx);
        if (result === Failure) {
            return undefined;
        }
        else {
            updateSrcAndCtx();
            return result;
        }
    });
}
export function recover(parser, defaultValue) {
    return (src, ctx) => {
        const result = parser(src, ctx);
        if (result === Failure) {
            const ans = defaultValue(src, ctx);
            return ans;
        }
        return result;
    };
}
export function select(cases) {
    return (src, ctx) => {
        for (const { predicate, prefix, parser, regex } of cases) {
            if (predicate?.(src)
                ?? (prefix !== undefined ? src.tryPeek(prefix) : undefined)
                ?? (regex && src.matchPattern(regex))
                ?? true) {
                const callableParser = typeof parser === 'object' ? parser.get() : parser;
                return callableParser(src, ctx);
            }
        }
        throw new Error('The select parser util was called with non-exhaustive cases');
    };
}
export function map(parser, fn) {
    return (src, ctx) => {
        const result = parser(src, ctx);
        if (result === Failure) {
            return Failure;
        }
        const ans = fn(result, src, ctx);
        return ans;
    };
}
export function setType(type, parser) {
    return map(parser, (res) => {
        const { type: _type, ...restResult } = res;
        const ans = { type, ...restResult };
        delete ans[SequenceUtilDiscriminator];
        return ans;
    });
}
export function validate(parser, validator, message, severity) {
    return map(parser, (res, src, ctx) => {
        const isLegal = validator(res, src, ctx);
        if (!isLegal) {
            ctx.err.report(message, res.range, severity);
        }
        return res;
    });
}
export function stopBefore(parser, ...terminators) {
    const flatTerminators = terminators.flat();
    return (src, ctx) => {
        const tmpSrc = src.clone();
        // Cut tmpSrc.string before the nearest terminator.
        tmpSrc.string = tmpSrc.string.slice(0, flatTerminators.reduce((p, c) => {
            const index = tmpSrc.string.indexOf(c, tmpSrc.innerCursor);
            return Math.min(p, index === -1 ? Infinity : index);
        }, Infinity));
        const ans = parser(tmpSrc, ctx);
        src.cursor = tmpSrc.cursor;
        return ans;
    };
}
export function concatOnTrailingBackslash(parser) {
    return (src, ctx) => {
        let wrappedStr = src.sliceToCursor(0);
        const wrappedSrcCursor = wrappedStr.length;
        const indexMap = [];
        while (src.canRead()) {
            wrappedStr += src.readUntil('\\');
            if (!src.canRead()) {
                break;
            }
            // If we get here, then `src.cursor` is at a backslash
            if (src.hasNonSpaceAheadInLine(1)) {
                wrappedStr += src.read();
                continue;
            }
            // Create an index map that skips from the trailing backslash to the
            // next line's first non-whitespace character
            const from = src.getCharRange();
            src.nextLine();
            // Minecraft raises a `Line continuation at end of file` if a backslash
            // (+ optional whitespace to the next line) is right before the end of the file
            if (!src.canRead()) {
                const ans = { type: 'error', range: Range.span(from, src) };
                ctx.err.report(localize('parser.line-continuation-end-of-file'), ans);
            }
            src.skipSpace();
            const to = src.getCharRange(-1);
            indexMap.push({ inner: Range.create(wrappedStr.length), outer: Range.span(from, to) });
        }
        const wrappedSrc = new Source(wrappedStr, indexMap);
        wrappedSrc.innerCursor = wrappedSrcCursor;
        const ans = parser(wrappedSrc, ctx);
        src.cursor = wrappedSrc.cursor;
        return ans;
    };
}
export function acceptOnly(parser, ...characters) {
    const set = new Set(characters.flat());
    return (src, ctx) => {
        const tmpSrc = src.clone();
        // Cut tmpSrc.string before the nearest unacceptable character.
        for (let i = tmpSrc.innerCursor; i < tmpSrc.string.length; i++) {
            if (!set.has(tmpSrc.string.charAt(i))) {
                tmpSrc.string = tmpSrc.string.slice(0, i);
                break;
            }
        }
        const ans = parser(tmpSrc, ctx);
        src.cursor = tmpSrc.cursor;
        return ans;
    };
}
export function acceptIf(parser, predicate) {
    return ((src, ctx) => {
        const tmpSrc = src.clone();
        // Cut tmpSrc.string before the nearest unacceptable character.
        for (let i = tmpSrc.innerCursor; i < tmpSrc.string.length; i++) {
            if (!predicate(tmpSrc.string.charAt(i))) {
                tmpSrc.string = tmpSrc.string.slice(0, i);
                break;
            }
        }
        const ans = parser(tmpSrc, ctx);
        src.innerCursor = tmpSrc.innerCursor;
        return ans;
    });
}
/**
 * @returns A parser that dumps any parser errors after it finishes parsing.
 */
export function dumpErrors(parser) {
    return ((src, ctx) => {
        const ans = parser(src, ctx);
        ctx.err.dump();
        return ans;
    });
}
//# sourceMappingURL=util.js.map