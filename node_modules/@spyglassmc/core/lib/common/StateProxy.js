import { emplaceMap, isObject } from '../common/index.js';
import { Operations } from './Operations.js';
const BranchOff = Symbol('StateBranchOff');
const Is = Symbol('IsStateProxy');
const Origin = Symbol('OriginState');
const Redo = Symbol('RedoStateChanges');
const Undo = Symbol('UndoStateChanges');
export var StateProxy;
(function (StateProxy) {
    function branchOff(proxy) {
        return proxy[BranchOff]();
    }
    StateProxy.branchOff = branchOff;
    function create(obj) {
        if (StateProxy.is(obj)) {
            throw new TypeError('Cannot create a proxy over a proxy. You might want to use branchOff instead.');
        }
        return _createStateProxy(obj, new Operations());
    }
    StateProxy.create = create;
    function dereference(value) {
        return StateProxy.is(value) ? value[Origin] : value;
    }
    StateProxy.dereference = dereference;
    function is(obj) {
        return obj?.[Is];
    }
    StateProxy.is = is;
    function redoChanges(proxy) {
        proxy[Redo]();
    }
    StateProxy.redoChanges = redoChanges;
    function undoChanges(proxy) {
        proxy[Undo]();
    }
    StateProxy.undoChanges = undoChanges;
})(StateProxy || (StateProxy = {}));
class StateProxyHandler {
    rootOps;
    map = new Map();
    constructor(
    /**
     * Shared across all handlers created for the same root state object under the same branch.
     */
    rootOps) {
        this.rootOps = rootOps;
    }
    #branchOff(target) {
        return _createStateProxy(target, new Operations(this.rootOps));
    }
    get(target, p, receiver) {
        switch (p) {
            case BranchOff:
                return () => this.#branchOff(target);
            case Is:
                return true;
            case Origin:
                return target;
            case Redo:
                return () => this.rootOps.redo();
            case Undo:
                return () => this.rootOps.undo();
        }
        const value = Reflect.get(target, p, receiver);
        if (p !== 'prototype' && isObject(value)) {
            return emplaceMap(this.map, p, { insert: () => _createStateProxy(value, this.rootOps) });
        }
        return value;
    }
    set(target, p, value, receiver) {
        if (p === BranchOff || p === Is || p === Origin || p === Redo || p === Undo) {
            throw new TypeError(`Cannot set ${String(p)}`);
        }
        this.rootOps.set(target, p, StateProxy.dereference(value), receiver);
        return true;
    }
}
function _createStateProxy(target, operations) {
    return new Proxy(target, new StateProxyHandler(operations));
}
//# sourceMappingURL=StateProxy.js.map