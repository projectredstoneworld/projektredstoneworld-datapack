import { IndexMap } from './IndexMap.js';
import { Range } from './Range.js';
export const CRLF = '\r\n';
export const CR = '\r';
export const LF = '\n';
export const Whitespaces = Object.freeze([' ', '\n', '\r', '\t']);
export class ReadonlySource {
    string;
    indexMap;
    innerCursor = 0;
    constructor(string, indexMap = []) {
        this.string = string;
        this.indexMap = indexMap;
    }
    get cursor() {
        return IndexMap.toOuterOffset(this.indexMap, this.innerCursor);
    }
    /**
     * @param offset The index to offset from cursor. Defaults to 0.
     *
     * @returns The range of the specified character.
     *
     * @example
     * getCharRange(-1) // Returns the range of the character before cursor.
     * getCharRange()   // Returns the range of the character at cursor.
     * getCharRange(1)  // Returns the range of the character after cursor.
     */
    getCharRange(offset = 0) {
        return IndexMap.toOuterRange(this.indexMap, Range.create(this.innerCursor + offset, this.innerCursor + offset + 1));
    }
    /**
     * Returns a string that helps visualize this `Source`'s index map.
     * Primarily intended for debugging purposes.
     */
    visualizeIndexMap() {
        let res = this.string;
        const adjustments = [];
        for (const { inner, outer } of this.indexMap) {
            const innerLength = inner.end - inner.start;
            const outerLength = outer.end - outer.start;
            const { char, count } = outerLength > innerLength
                ? {
                    count: outerLength - innerLength,
                    char: '\u2190', // ←
                }
                : { count: outer.start - inner.start, char: '\u2017' }; // ‗
            adjustments.push({ idx: inner.start, str: char.repeat(count) });
        }
        for (const { idx, str } of adjustments.reverse()) {
            res = `${res.slice(0, idx)}${str}${res.slice(idx)}`;
        }
        return res;
    }
    /**
     * Peeks a substring from the current cursor.
     * @param length The length of the substring. Defaults to 1
     * @param offset The index to offset from cursor. Defaults to 0
     */
    peek(length = 1, offset = 0) {
        return this.string.slice(this.innerCursor + offset, this.innerCursor + offset + length);
    }
    canRead(length = 1) {
        const needed = this.innerCursor + length;
        const available = this.string.length;
        return this.innerCursor + length <= this.string.length;
    }
    canReadInLine() {
        return this.canRead() && this.peek() !== CR && this.peek() !== LF;
    }
    /**
     * If the `expectedValue` is right after the cursor, returns `true`. Otherwise returns `false`.
     *
     * @param offset Defaults to 0.
     *
     * @see {@link Source.trySkip}
     */
    tryPeek(expectedValue, offset = 0) {
        return this.peek(expectedValue.length, offset) === expectedValue;
    }
    tryPeekAfterWhitespace(expectedValue) {
        const maxOffset = this.string.length - this.innerCursor;
        let offset = 0;
        while (offset < maxOffset && Source.isWhitespace(this.peek(1, offset))) {
            offset++;
        }
        return this.tryPeek(expectedValue, offset);
    }
    peekUntil(...terminators) {
        let ans = '';
        for (let cursor = this.innerCursor; cursor < this.string.length; cursor++) {
            const c = this.string.charAt(cursor);
            if (terminators.includes(c)) {
                return ans;
            }
            else {
                ans += c;
            }
        }
        return ans;
    }
    peekLine() {
        return this.peekUntil(CR, LF);
    }
    peekRemaining(offset = 0) {
        return this.string.slice(this.innerCursor + offset);
    }
    matchPattern(regex, offset = 0) {
        return regex.test(this.peekRemaining(offset));
    }
    /**
     * If there is a non-space character between `cursor + offset` (inclusive) and the next newline, returns `true`. Otherwise returns `false`.
     *
     * @param offset Defaults to 0.
     */
    hasNonSpaceAheadInLine(offset = 0) {
        for (let cursor = this.innerCursor + offset; cursor < this.string.length; cursor++) {
            const c = this.string.charAt(cursor);
            if (Source.isNewline(c)) {
                break;
            }
            if (!Source.isSpace(c)) {
                return true;
            }
        }
        return false;
    }
    slice(param0, end) {
        if (typeof param0 === 'number') {
            const innerStart = IndexMap.toInnerOffset(this.indexMap, param0);
            const innerEnd = end !== undefined ? IndexMap.toInnerOffset(this.indexMap, end) : undefined;
            return this.string.slice(innerStart, innerEnd);
        }
        const range = IndexMap.toInnerRange(this.indexMap, Range.get(param0));
        return this.string.slice(range.start, range.end);
    }
    sliceToCursor(start) {
        const innerStart = IndexMap.toInnerOffset(this.indexMap, start);
        return this.string.slice(innerStart, this.innerCursor);
    }
}
export class Source extends ReadonlySource {
    string;
    indexMap;
    constructor(string, indexMap = []) {
        super(string, indexMap);
        this.string = string;
        this.indexMap = indexMap;
    }
    get cursor() {
        return super.cursor;
    }
    set cursor(cursor) {
        this.innerCursor = IndexMap.toInnerOffset(this.indexMap, cursor);
    }
    clone() {
        const ans = new Source(this.string, this.indexMap);
        ans.innerCursor = this.innerCursor;
        return ans;
    }
    read() {
        return this.string.charAt(this.innerCursor++);
    }
    /**
     * Skips the current character.
     * @param step The step to skip. Defaults to 1
     */
    skip(step = 1) {
        this.innerCursor += step;
        return this;
    }
    /**
     * If the `expectedValue` is right after the cursor, skips it and returns `true`. Otherwise returns `false`.
     *
     * This is a shortcut for the following piece of code:
     * ```typescript
     * declare const src: Source
     * if (src.peek(expectedValue.length) === expectedValue) {
     * 	src.skip(expectedValue.length)
     * 	// Do something here.
     * }
     * ```
     *
     * @see {@link Source.tryPeek}
     */
    trySkip(expectedValue) {
        if (this.peek(expectedValue.length) === expectedValue) {
            this.skip(expectedValue.length);
            return true;
        }
        return false;
    }
    /**
     * Reads until the end of this line.
     */
    readLine() {
        return this.readUntil(CR, LF);
    }
    /**
     * Skips until the end of this line.
     */
    skipLine() {
        this.readLine();
        return this;
    }
    /**
     * Jumps to the beginning of the next line.
     */
    nextLine() {
        this.skipLine();
        if (this.peek(2) === CRLF) {
            this.skip(2);
        }
        else if (this.peek() === CR || this.peek() === LF) {
            this.skip();
        }
        return this;
    }
    readSpace() {
        const start = this.innerCursor;
        this.skipSpace();
        return this.string.slice(start, this.innerCursor);
    }
    skipSpace() {
        while (this.canRead() && Source.isSpace(this.peek())) {
            this.skip();
        }
        return this;
    }
    readWhitespace() {
        const start = this.innerCursor;
        this.skipWhitespace();
        return this.string.slice(start, this.innerCursor);
    }
    skipWhitespace() {
        while (this.canRead() && Source.isWhitespace(this.peek())) {
            this.skip();
        }
        return this;
    }
    readIf(predicate) {
        let ans = '';
        while (this.canRead()) {
            const c = this.peek();
            if (predicate(c)) {
                this.skip();
                ans += c;
            }
            else {
                break;
            }
        }
        return ans;
    }
    skipIf(predicate) {
        this.readIf(predicate);
        return this;
    }
    /**
     * @param terminators Ending character. Will not be skipped or included in the result.
     */
    readUntil(...terminators) {
        let ans = '';
        while (this.canRead()) {
            const c = this.peek();
            if (terminators.includes(c)) {
                return ans;
            }
            else {
                ans += c;
            }
            this.skip();
        }
        return ans;
    }
    /**
     * @param terminators Ending character. Will not be skipped.
     */
    skipUntilOrEnd(...terminators) {
        this.readUntil(...terminators);
        return this;
    }
    readUntilLineEnd() {
        return this.readUntil(CR, LF);
    }
    skipUntilLineEnd() {
        return this.skipUntilOrEnd(CR, LF);
    }
    readRemaining() {
        const start = this.innerCursor;
        this.innerCursor = this.string.length;
        return this.string.slice(start);
    }
    skipRemaining() {
        this.readRemaining();
        return this;
    }
}
(function (Source) {
    function isDigit(c) {
        return c >= '0' && c <= '9';
    }
    Source.isDigit = isDigit;
    function isBrigadierQuote(c) {
        return c === '"' || c === "'";
    }
    Source.isBrigadierQuote = isBrigadierQuote;
    function isNewline(c) {
        return c === '\r\n' || c === '\r' || c === '\n';
    }
    Source.isNewline = isNewline;
    function isSpace(c) {
        return c === ' ' || c === '\t';
    }
    Source.isSpace = isSpace;
    function isWhitespace(c) {
        return Source.isSpace(c) || Source.isNewline(c);
    }
    Source.isWhitespace = isWhitespace;
})(Source || (Source = {}));
//# sourceMappingURL=Source.js.map