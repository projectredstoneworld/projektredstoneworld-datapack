import * as core from '@spyglassmc/core';
import { any, Arrayable, failOnEmpty, failOnError, Failure, map, optional, Range, repeat, ResourceLocation, select, sequence, setType, stopBefore, validate, } from '@spyglassmc/core';
import { arrayToMessage, localeQuote, localize } from '@spyglassmc/locales';
import { RangeExclusiveChar } from '../node/index.js';
import { NumericTypeFloatKinds, NumericTypeIntKinds, PrimitiveArrayValueKinds, StaticIndexKeywords, } from '../type/index.js';
/**
 * @returns A comment parser that accepts normal comments (`//`) and reports an error if it's a doc comment (`///`).
 *
 * `Failure` when there isn't a comment.
 */
export const comment = validate(core.comment({ singleLinePrefixes: new Set(['//']) }), (res, src) => !src.slice(res).startsWith('///'), localize('mcdoc.parser.syntax.doc-comment-unexpected'));
/**
 * @returns A parser that parses the gap between **SYNTAX** rules, which may contains whitespace and regular comments.
 */
function syntaxGap(
/* istanbul ignore next */
delegatesDocComments = false) {
    return (src, ctx) => {
        const ans = [];
        src.skipWhitespace();
        while (src.canRead() && src.peek(2) === '//' && (!delegatesDocComments || src.peek(3) !== '///')) {
            const result = comment(src, ctx);
            ans.push(result);
            src.skipWhitespace();
        }
        return ans;
    };
}
function syntax(parsers, delegatesDocComments = false) {
    return (src, ctx) => {
        src.skipWhitespace();
        const ans = sequence(parsers, syntaxGap(delegatesDocComments))(src, ctx);
        src.skipWhitespace();
        return ans;
    };
}
function syntaxRepeat(parser, delegatesDocComments = false) {
    return repeat(parser, syntaxGap(delegatesDocComments));
}
export function literal(literal, options) {
    return (src, ctx) => {
        const ans = {
            type: 'mcdoc:literal',
            range: Range.create(src),
            value: '',
            colorTokenType: options?.colorTokenType,
        };
        ans.value = src.readIf((c) => options?.allowedChars?.has(c) ?? (options?.specialChars?.has(c) || /[a-z]/i.test(c)));
        ans.range.end = src.cursor;
        if (Arrayable.toArray(literal).every((l) => l !== ans.value)) {
            ctx.err.report(localize('expected-got', arrayToMessage(literal), localeQuote(ans.value)), ans);
        }
        return ans;
    };
}
function keyword(keyword, options = { colorTokenType: 'keyword' }) {
    return (src, ctx) => {
        const result = literal(keyword, options)(src, ctx);
        if (!Arrayable.toArray(keyword).includes(result.value)) {
            return Failure;
        }
        return result;
    };
}
function punctuation(punctuation) {
    return (src, ctx) => {
        src.skipWhitespace();
        if (!src.trySkip(punctuation)) {
            ctx.err.report(localize('expected-got', localeQuote(punctuation), localeQuote(src.peek())), src);
        }
        return undefined;
    };
}
function marker(punctuation) {
    return (src, _ctx) => {
        src.skipWhitespace();
        if (!src.trySkip(punctuation)) {
            return Failure;
        }
        return undefined;
    };
}
export function resLoc(options) {
    return validate(core.resourceLocation(options), (res) => res.namespace !== undefined, localize('mcdoc.parser.resource-location.colon-expected', localeQuote(ResourceLocation.NamespacePathSep)));
}
const UnicodeControlCharacters = Object.freeze([
    '\x00',
    '\x01',
    '\x02',
    '\x03',
    '\x04',
    '\x05',
    '\x06',
    '\x07',
    '\x08',
    '\x09',
    '\x0A',
    '\x0B',
    '\x0C',
    '\x0D',
    '\x0E',
    '\x0F',
    '\x7F',
]);
export const string = stopBefore(core.string({
    escapable: { characters: ['b', 'f', 'n', 'r', 't', '\\', '"'], unicode: true },
    quotes: ['"'],
}), ...UnicodeControlCharacters);
export const identifier = (src, ctx) => {
    // https://spyglassmc.com/user/mcdoc/#identifier
    const IdentifierStart = /^[\p{L}\p{Nl}]$/u;
    const IdentifierContinue = /^[\p{L}\p{Nl}\u200C\u200D\p{Mn}\p{Mc}\p{Nd}\p{Pc}]$/u;
    const ReservedWords = new Set([
        'any',
        'boolean',
        'byte',
        'double',
        'enum',
        'false',
        'float',
        'int',
        'long',
        'short',
        'string',
        'struct',
        'super',
        'true',
    ]);
    const ans = {
        type: 'mcdoc:identifier',
        range: Range.create(src),
        options: { category: 'mcdoc' },
        value: '',
    };
    const start = src.innerCursor;
    if (IdentifierStart.test(src.peek())) {
        src.skip();
        while (IdentifierContinue.test(src.peek())) {
            src.skip();
        }
    }
    else {
        ctx.err.report(localize('expected', localize('mcdoc.node.identifier')), src);
    }
    ans.value = src.string.slice(start, src.innerCursor);
    ans.range.end = src.cursor;
    if (ReservedWords.has(ans.value)) {
        ctx.err.report(localize('mcdoc.parser.identifier.reserved-word', localeQuote(ans.value)), ans);
    }
    return ans;
};
function indexBody(options) {
    const accessorKey = select([
        { prefix: '%', parser: literal(['%key', '%parent'], { specialChars: new Set(['%']) }) },
        { prefix: '"', parser: string },
        { parser: identifier },
    ]);
    const dynamicIndex = setType('mcdoc:dynamic_index', syntax([
        punctuation('['),
        accessorKey,
        repeat(sequence([marker('.'), accessorKey])),
        punctuation(']'),
    ]));
    const index = select([
        {
            prefix: '%',
            parser: literal(StaticIndexKeywords.map((v) => `%${v}`), { specialChars: new Set(['%']) }),
        },
        { prefix: '"', parser: string },
        {
            prefix: '[',
            parser: options?.noDynamic
                ? validate(dynamicIndex, () => false, localize('mcdoc.parser.index-body.dynamic-index-not-allowed'))
                : dynamicIndex,
        },
        {
            parser: any([
                resLoc({ category: 'mcdoc/dispatcher', accessType: options?.accessType }),
                identifier,
            ]),
        },
    ]);
    return setType('mcdoc:index_body', syntax([
        punctuation('['),
        index,
        syntaxRepeat(syntax([marker(','), failOnEmpty(index)])),
        optional(marker(',')),
        punctuation(']'),
    ]));
}
const pathSegment = select([{
        prefix: 'super',
        parser: literal('super'),
    }, { parser: identifier }]);
export const path = (src, ctx) => {
    let isAbsolute;
    if (src.trySkip('::')) {
        isAbsolute = true;
    }
    return map(sequence([pathSegment, repeat(sequence([marker('::'), pathSegment]))]), (res) => {
        const ans = {
            type: 'mcdoc:path',
            children: res.children,
            range: res.range,
            isAbsolute,
        };
        return ans;
    })(src, ctx);
};
const attributeTreePosValues = setType('mcdoc:attribute/tree/pos', syntax([
    { get: () => attributeValue },
    syntaxRepeat(syntax([marker(','), { get: () => failOnEmpty(attributeValue) }], true), true),
], true));
const attributeNamedValue = syntax([
    select([{ prefix: '"', parser: string }, { parser: identifier }]),
    select([{
            prefix: '=',
            parser: syntax([punctuation('='), { get: () => attributeValue }], true),
        }, { parser: { get: () => attributeTree } }]),
], true);
const attributeTreeNamedValues = setType('mcdoc:attribute/tree/named', syntax([
    attributeNamedValue,
    syntaxRepeat(syntax([marker(','), failOnEmpty(attributeNamedValue)], true), true),
], true));
const treeBody = any([
    syntax([attributeTreeNamedValues, optional(marker(','))]),
    syntax([
        attributeTreePosValues,
        punctuation(','),
        attributeTreeNamedValues,
        optional(marker(',')),
    ]),
    syntax([attributeTreePosValues, optional(marker(','))]),
]);
export const AttributeTreeClosure = Object.freeze({ '(': ')', '[': ']', '{': '}' });
const attributeTree = (src, ctx) => {
    const delim = src.trySkip('(')
        ? '('
        : src.trySkip('[')
            ? '['
            : src.trySkip('{')
                ? '{'
                : undefined;
    if (!delim) {
        return Failure;
    }
    const res = treeBody(src, ctx);
    const ans = {
        type: 'mcdoc:attribute/tree',
        range: res.range,
        children: res.children,
        delim,
    };
    src.trySkip(AttributeTreeClosure[delim]);
    return ans;
};
const attributeValue = select([{
        predicate: (src) => ['(', '[', '{'].includes(src.peek()),
        parser: attributeTree,
    }, { parser: { get: () => type } }]);
export const attribute = setType('mcdoc:attribute', syntax([
    marker('#['),
    identifier,
    select([{
            prefix: '=',
            parser: syntax([punctuation('='), attributeValue, punctuation(']')], true),
        }, {
            predicate: (src) => ['(', '[', '{'].includes(src.peek()),
            parser: syntax([attributeTree, punctuation(']')], true),
        }, { parser: punctuation(']') }]),
], true));
const attributes = repeat(attribute);
const typeParam = setType('mcdoc:type_param', syntax([
    identifier,
    // optional(syntax([failOnError(literal('extends')), { get: () => type }])),
]));
const typeParamBlock = setType('mcdoc:type_param_block', syntax([
    punctuation('<'),
    select([{ prefix: '>', parser: punctuation('>') }, {
            parser: syntax([
                typeParam,
                syntaxRepeat(syntax([marker(','), failOnEmpty(typeParam)])),
                optional(marker(',')),
                punctuation('>'),
            ]),
        }]),
]));
const noop = () => undefined;
export const docComment = core.comment({
    singleLinePrefixes: new Set(['///']),
    includesEol: true,
});
export const docComments = setType('mcdoc:doc_comments', repeat(docComment, (src) => {
    src.skipWhitespace();
    return [];
}));
const prelim = syntax([
    optional(failOnEmpty(docComments)),
    attributes,
]);
const optionalTypeParamBlock = select([{
        prefix: '<',
        parser: typeParamBlock,
    }, { parser: noop }]);
export const dispatchStatement = setType('mcdoc:dispatch_statement', syntax([
    prelim,
    keyword('dispatch'),
    resLoc({ category: 'mcdoc/dispatcher', accessType: 1 /* SymbolAccessType.Write */ }),
    indexBody({ noDynamic: true }),
    optionalTypeParamBlock,
    literal('to'),
    { get: () => type },
], true));
const enumType = literal([
    'byte',
    'short',
    'int',
    'long',
    'string',
    'float',
    'double',
], { colorTokenType: 'type' });
export const float = core.float({
    pattern: /^[-+]?(?:[0-9]+(?:[eE][-+]?[0-9]+)?|[0-9]*\.[0-9]+(?:[eE][-+]?[0-9]+)?)$/,
});
export const integer = core.integer({
    pattern: /^(?:0|[-+]?[1-9][0-9]*)$/,
});
export const LiteralIntSuffixes = Object.freeze(['b', 's', 'l']);
export const LiteralIntCaseInsensitiveSuffixes = Object.freeze([...LiteralIntSuffixes, 'B', 'S', 'L']);
export const LiteralFloatSuffixes = Object.freeze(['f', 'd']);
export const LiteralFloatCaseInsensitiveSuffixes = Object.freeze([...LiteralFloatSuffixes, 'F', 'D']);
export const LiteralNumberSuffixes = Object.freeze([...LiteralIntSuffixes, ...LiteralFloatSuffixes]);
export const LiteralNumberCaseInsensitiveSuffixes = Object.freeze([
    ...LiteralNumberSuffixes,
    ...LiteralIntCaseInsensitiveSuffixes,
    ...LiteralFloatCaseInsensitiveSuffixes,
]);
export const typedNumber = setType('mcdoc:typed_number', select([{
        regex: /^(?:\+|-)?\d+(?!\d|[.dfe])/i,
        parser: sequence([
            integer,
            optional(keyword(LiteralIntCaseInsensitiveSuffixes, { colorTokenType: 'keyword' })),
        ]),
    }, {
        parser: sequence([
            float,
            optional(keyword(LiteralFloatCaseInsensitiveSuffixes, { colorTokenType: 'keyword' })),
        ]),
    }]));
const enumValue = select([{ prefix: '"', parser: string }, {
        parser: typedNumber,
    }]);
const enumField = setType('mcdoc:enum/field', syntax([prelim, identifier, punctuation('='), enumValue], true));
const enumBlock = setType('mcdoc:enum/block', syntax([
    punctuation('{'),
    select([{ prefix: '}', parser: punctuation('}') }, {
            parser: syntax([
                enumField,
                syntaxRepeat(syntax([marker(','), failOnEmpty(enumField)], true), true),
                optional(marker(',')),
                punctuation('}'),
            ], true),
        }]),
], true));
export const enum_ = setType('mcdoc:enum', syntax([
    prelim,
    keyword('enum'),
    punctuation('('),
    enumType,
    punctuation(')'),
    optional(failOnError(identifier)),
    enumBlock,
], true));
const structMapKey = setType('mcdoc:struct/map_key', syntax([punctuation('['), { get: () => type }, punctuation(']')], true));
const structKey = select([{ prefix: '"', parser: string }, {
        prefix: '[',
        parser: structMapKey,
    }, { parser: identifier }]);
const structPairField = (src, ctx) => {
    let isOptional;
    const result0 = syntax([prelim, structKey], true)(src, ctx);
    if (src.trySkip('?')) {
        isOptional = true;
    }
    const result1 = syntax([punctuation(':'), { get: () => type }], true)(src, ctx);
    const ans = {
        type: 'mcdoc:struct/field/pair',
        children: [...result0.children, ...result1.children],
        range: Range.span(result0, result1),
        isOptional,
    };
    return ans;
};
const structSpreadField = setType('mcdoc:struct/field/spread', syntax([attributes, marker('...'), { get: () => type }], true));
const structField = any([
    structSpreadField,
    structPairField,
]);
const structBlock = setType('mcdoc:struct/block', syntax([
    punctuation('{'),
    select([{ prefix: '}', parser: punctuation('}') }, {
            parser: syntax([
                structField,
                syntaxRepeat(syntax([marker(','), failOnEmpty(structField)], true), true),
                optional(marker(',')),
                punctuation('}'),
            ], true),
        }]),
], true));
export const struct = setType('mcdoc:struct', syntax([prelim, keyword('struct'), optional(failOnEmpty(identifier)), structBlock], true));
const enumInjection = setType('mcdoc:injection/enum', syntax([literal('enum'), punctuation('('), enumType, punctuation(')'), path, enumBlock]));
const structInjection = setType('mcdoc:injection/struct', syntax([literal('struct'), path, structBlock]));
export const injection = setType('mcdoc:injection', syntax([
    keyword('inject'),
    select([{ prefix: 'enum', parser: enumInjection }, { parser: structInjection }]),
]));
export const typeAliasStatement = setType('mcdoc:type_alias', syntax([prelim, keyword('type'), identifier, optionalTypeParamBlock, punctuation('='), {
        get: () => type,
    }], true));
export const useStatement = setType('mcdoc:use_statement', syntax([
    keyword('use'),
    path,
    select([{ prefix: 'as', parser: syntax([literal('as'), identifier]) }, { parser: noop }]),
], true));
const topLevel = any([
    comment,
    dispatchStatement,
    enum_,
    injection,
    struct,
    typeAliasStatement,
    useStatement,
]);
export const module_ = setType('mcdoc:module', syntaxRepeat(topLevel, true));
const typeArgBlock = setType('mcdoc:type_arg_block', syntax([
    marker('<'),
    select([{ prefix: '>', parser: punctuation('>') }, {
            parser: syntax([
                { get: () => type },
                syntaxRepeat(syntax([marker(','), { get: () => failOnEmpty(type) }], true), true),
                optional(marker(',')),
                punctuation('>'),
            ], true),
        }]),
]));
function typeBase(type, parser) {
    return setType(type, syntax([
        attributes,
        parser,
        syntaxRepeat(select([{ prefix: '<', parser: typeArgBlock }, { parser: failOnError(indexBody()) }]), true),
    ], true));
}
export const anyType = typeBase('mcdoc:type/any', keyword('any', { colorTokenType: 'type' }));
export const booleanType = typeBase('mcdoc:type/boolean', keyword('boolean', { colorTokenType: 'type' }));
function range(type, number) {
    const delimiterPredicate = (src) => src.tryPeek('..') || src.tryPeek(`${RangeExclusiveChar}..`);
    const delimiterParser = literal([
        '..',
        `..${RangeExclusiveChar}`,
        `${RangeExclusiveChar}..`,
        `${RangeExclusiveChar}..${RangeExclusiveChar}`,
    ], { allowedChars: new Set(['.', RangeExclusiveChar]) });
    return setType(type, select([{ predicate: delimiterPredicate, parser: sequence([delimiterParser, number]) }, {
            parser: sequence([
                stopBefore(number, '..'),
                select([{
                        predicate: delimiterPredicate,
                        parser: sequence([delimiterParser, optional(failOnEmpty(number))]),
                    }, { parser: noop }]),
            ]),
        }]));
}
export const intRange = range('mcdoc:int_range', integer);
const atIntRange = optional((src, ctx) => {
    if (!src.trySkip('@')) {
        return Failure;
    }
    src.skipWhitespace();
    return intRange(src, ctx);
});
export const stringType = typeBase('mcdoc:type/string', syntax([
    keyword('string', { colorTokenType: 'type' }),
    atIntRange,
], true));
export const literalType = typeBase('mcdoc:type/literal', select([
    {
        predicate: (src) => src.tryPeek('false') || src.tryPeek('true'),
        parser: keyword(['false', 'true'], { colorTokenType: 'type' }),
    },
    { prefix: '"', parser: failOnEmpty(string) },
    { parser: failOnError(typedNumber) },
]));
export const floatRange = range('mcdoc:float_range', float);
const atFloatRange = optional((src, ctx) => {
    if (!src.trySkip('@')) {
        return Failure;
    }
    src.skipWhitespace();
    return floatRange(src, ctx);
});
export const numericType = typeBase('mcdoc:type/numeric_type', select([{
        predicate: (src) => NumericTypeFloatKinds.some((k) => src.tryPeek(k)),
        parser: syntax([keyword(NumericTypeFloatKinds, { colorTokenType: 'type' }), atFloatRange], true),
    }, {
        parser: syntax([keyword(NumericTypeIntKinds, { colorTokenType: 'type' }), atIntRange], true),
    }]));
export const primitiveArrayType = typeBase('mcdoc:type/primitive_array', syntax([
    literal(PrimitiveArrayValueKinds),
    atIntRange,
    keyword('[]', { allowedChars: new Set(['[', ']']), colorTokenType: 'type' }),
    atIntRange,
]));
export const listType = typeBase('mcdoc:type/list', syntax([marker('['), { get: () => type }, punctuation(']'), atIntRange], true));
export const tupleType = typeBase('mcdoc:type/tuple', syntax([
    marker('['),
    { get: () => type },
    marker(','),
    select([{ prefix: ']', parser: punctuation(']') }, {
            parser: syntax([
                { get: () => type },
                syntaxRepeat(syntax([marker(','), { get: () => failOnEmpty(type) }], true), true),
                optional(marker(',')),
                punctuation(']'),
            ], true),
        }]),
], true));
export const dispatcherType = typeBase('mcdoc:type/dispatcher', syntax([failOnError(resLoc({ category: 'mcdoc/dispatcher' })), indexBody()]));
export const unionType = typeBase('mcdoc:type/union', syntax([
    marker('('),
    select([{ prefix: ')', parser: punctuation(')') }, {
            parser: syntax([
                { get: () => type },
                syntaxRepeat(syntax([marker('|'), { get: () => failOnEmpty(type) }], true), true),
                optional(marker('|')),
                punctuation(')'),
            ], true),
        }]),
]));
export const referenceType = typeBase('mcdoc:type/reference', syntax([path]));
export const type = any([
    anyType,
    booleanType,
    dispatcherType,
    enum_,
    listType,
    literalType,
    numericType,
    primitiveArrayType,
    stringType,
    struct,
    tupleType,
    unionType,
    referenceType,
]);
//# sourceMappingURL=index.js.map