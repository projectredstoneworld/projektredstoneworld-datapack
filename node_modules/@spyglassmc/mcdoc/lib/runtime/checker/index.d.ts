import type { CheckerContext, FullResourceLocation } from '@spyglassmc/core';
import { type EnumKind } from '../../node/index.js';
import type { EnumType, Index, KeywordType, ListType, LiteralType, NumericType, ParallelIndices, PrimitiveArrayType, StringType, StructType, StructTypePairField, TupleType, UnionType } from '../../type/index.js';
import { McdocType } from '../../type/index.js';
import type { NodeEquivalenceChecker, RuntimeNode } from './context.js';
import { McdocCheckerContext } from './context.js';
import type { McdocRuntimeError } from './error.js';
export * from './context.js';
export * from './error.js';
export type SimplifiedMcdocType = SimplifiedMcdocTypeNoUnion | UnionType<SimplifiedMcdocTypeNoUnion>;
export type SimplifiedMcdocTypeNoUnion = SimplifiedEnum | KeywordType | ListType | LiteralType | NumericType | PrimitiveArrayType | StringType | SimplifiedStructType | TupleType;
export interface SimplifiedEnum extends EnumType {
    enumKind: EnumKind;
}
export interface SimplifiedStructType extends StructType {
    fields: SimplifiedStructTypePairField[];
}
export interface SimplifiedStructTypePairField extends StructTypePairField {
    key: SimplifiedMcdocTypeNoUnion;
}
export declare function reference<T>(node: RuntimeNode<T>[], path: string, ctx: McdocCheckerContext<T>): void;
export declare function dispatcher<T>(node: RuntimeNode<T>[], registry: FullResourceLocation, index: string | Index | ParallelIndices, ctx: McdocCheckerContext<T>): void;
export declare function isAssignable(assignValue: McdocType, typeDef: McdocType, ctx: CheckerContext, isEquivalent?: NodeEquivalenceChecker): boolean;
export interface CheckerTreeNode<T> {
    parent: CheckerTreeRuntimeNode<T> | undefined;
    runtimeKey: RuntimeNode<T> | undefined;
    possibleValues: CheckerTreeRuntimeNode<T>[];
}
export interface CheckerTreeRuntimeNode<T> {
    entryNode: CheckerTreeNode<T>;
    children: CheckerTreeNode<T>[];
    node: RuntimeNode<T>;
    definitionsByParent: CheckerTreeDefinitionGroupNode<T>[];
}
export interface CheckerTreeDefinitionGroupNode<T> {
    parents: CheckerTreeDefinitionNode<T>[];
    runtimeNode: CheckerTreeRuntimeNode<T>;
    condensedErrors: McdocRuntimeError<T>[][];
    desc?: string;
    keyDefinition: SimplifiedMcdocTypeNoUnion | undefined;
    originalTypeDef: McdocType;
    validDefinitions: CheckerTreeDefinitionNode<T>[];
}
export interface CheckerTreeDefinitionNode<T> {
    groupNode: CheckerTreeDefinitionGroupNode<T>;
    typeDef: SimplifiedMcdocTypeNoUnion;
    children: CheckerTreeDefinitionGroupNode<T>[];
}
export declare function typeDefinition<T>(runtimeValues: RuntimeNode<T>[], typeDef: McdocType, ctx: McdocCheckerContext<T>): void;
export declare function getPossibleTypes(typeDef: McdocType): Exclude<McdocType, UnionType>[];
/**
 * Basically the same as a {@link CheckerTreeRuntimeNode}, just with a few fields
 * that aren't needed here removed for simplicity.
 *
 * This means {@link CheckerTreeRuntimeNode} can be used in place of this type without
 * any conversions as this type is compatible with {@link CheckerTreeRuntimeNode}.
 */
export interface SimplifyValueNode<T> {
    entryNode: {
        parent: SimplifyValueNode<T> | undefined;
        runtimeKey: RuntimeNode<T> | undefined;
    };
    node: RuntimeNode<T>;
}
export interface SimplifyContext<T> {
    node: SimplifyValueNode<T>;
    ctx: McdocCheckerContext<T>;
    isMember?: boolean;
    typeArgs?: SimplifiedMcdocType[];
    typeMapping?: {
        [path: string]: SimplifiedMcdocType;
    };
}
export interface SimplifyResult<T extends SimplifiedMcdocType> {
    typeDef: T;
    dynamicData?: boolean;
}
export declare function simplify<T>(typeDef: Exclude<McdocType, UnionType>, context: SimplifyContext<T>): SimplifyResult<SimplifiedMcdocTypeNoUnion>;
export declare function simplify<T>(typeDef: McdocType, context: SimplifyContext<T>): SimplifyResult<SimplifiedMcdocType>;
//# sourceMappingURL=index.d.ts.map