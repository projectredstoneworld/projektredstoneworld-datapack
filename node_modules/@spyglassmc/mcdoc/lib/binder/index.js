import { AsyncBinder, atArray, Dev, ErrorSeverity, Range, ResourceLocationNode, SymbolUtil, traversePreOrder, } from '@spyglassmc/core';
import { localeQuote, localize } from '@spyglassmc/locales';
import { AttributeNode, AttributeTreeNamedValuesNode, AttributeTreeNode, AttributeTreePosValuesNode, DispatcherTypeNode, DispatchStatementNode, DocCommentsNode, DynamicIndexNode, EnumBlockNode, EnumFieldNode, EnumInjectionNode, EnumNode, FloatRangeNode, IndexBodyNode, InjectionNode, IntRangeNode, ListTypeNode, LiteralNode, LiteralTypeNode, NumericTypeNode, PathNode, PrimitiveArrayTypeNode, ReferenceTypeNode, StaticIndexNode, StringTypeNode, StructBlockNode, StructMapKeyNode, StructNode, StructPairFieldNode, StructSpreadFieldNode, TopLevelNode, TupleTypeNode, TypeAliasNode, TypeArgBlockNode, TypeBaseNode, TypedNumberNode, TypeParamBlockNode, TypeParamNode, UnionTypeNode, UseStatementNode, } from '../node/index.js';
var ModuleSymbolData;
(function (ModuleSymbolData) {
    function is(data) {
        return (!!data
            && typeof data === 'object'
            && typeof data.nextAnonymousIndex === 'number');
    }
    ModuleSymbolData.is = is;
})(ModuleSymbolData || (ModuleSymbolData = {}));
export var TypeDefSymbolData;
(function (TypeDefSymbolData) {
    function is(data) {
        return (!!data
            && typeof data === 'object'
            && typeof data.typeDef === 'object');
    }
    TypeDefSymbolData.is = is;
})(TypeDefSymbolData || (TypeDefSymbolData = {}));
export const fileModule = AsyncBinder.create(async (node, ctx) => {
    const moduleIdentifier = uriToIdentifier(ctx.doc.uri, ctx);
    if (!moduleIdentifier) {
        ctx.err.report(localize('mcdoc.binder.out-of-root', localeQuote(ctx.doc.uri)), Range.Beginning, ErrorSeverity.Hint);
        return;
    }
    const mcdocCtx = { ...ctx, moduleIdentifier };
    return module_(node, mcdocCtx);
});
export async function module_(node, ctx) {
    const data = { nextAnonymousIndex: 0 };
    ctx.symbols.query({ doc: ctx.doc, node }, 'mcdoc', ctx.moduleIdentifier).amend({
        data: { data },
    });
    hoist(node, { ...ctx, isHoisting: true });
    for (const child of node.children) {
        switch (child.type) {
            case 'mcdoc:dispatch_statement':
                await bindDispatchStatement(child, ctx);
                break;
            case 'mcdoc:enum':
                bindEnum(child, ctx);
                break;
            case 'mcdoc:injection':
                await bindInjection(child, ctx);
                break;
            case 'mcdoc:struct':
                await bindStruct(child, ctx);
                break;
            case 'mcdoc:type_alias':
                await bindTypeAlias(child, ctx);
                break;
            case 'mcdoc:use_statement':
                await bindUseStatement(child, ctx);
                break;
        }
    }
}
/**
 * Hoist enums, structs, type aliases, and use statements under the module scope.
 */
function hoist(node, ctx) {
    traversePreOrder(node, () => true, TopLevelNode.is, (child) => {
        switch (child.type) {
            case 'mcdoc:enum':
                hoistEnum(child);
                break;
            case 'mcdoc:struct':
                hoistStruct(child);
                break;
            case 'mcdoc:type_alias':
                hoistTypeAlias(child);
                break;
            case 'mcdoc:use_statement':
                hoistUseStatement(child);
                break;
        }
    });
    function hoistEnum(node) {
        hoistFor('enum', node, EnumNode.destruct, (n) => ({ typeDef: convertEnum(n, ctx) }));
    }
    function hoistStruct(node) {
        hoistFor('struct', node, StructNode.destruct, (n) => ({ typeDef: convertStruct(n, ctx) }));
    }
    function hoistTypeAlias(node) {
        hoistFor('type_alias', node, TypeAliasNode.destruct, (n) => {
            const { attributes, rhs, typeParams } = TypeAliasNode.destruct(n);
            if (!rhs) {
                return undefined;
            }
            const ans = { typeDef: convertType(rhs, ctx) };
            if (typeParams) {
                bindTypeParamBlock(node, typeParams, ans, ctx);
            }
            appendAttributes(ans.typeDef, attributes, ctx);
            return ans;
        });
    }
    function hoistUseStatement(node) {
        const { binding, path } = UseStatementNode.destruct(node);
        if (!path) {
            return;
        }
        const { lastIdentifier } = PathNode.destruct(path);
        const identifier = binding ?? lastIdentifier;
        if (!identifier) {
            return;
        }
        // hoistUseStatement associates the AST node with the binding definition in the file symbol table,
        // which will get overridden by bindUseStatement in the later stage as an reference to the imported symbol in the global symbol table.
        // This way when the user tries to go to definition on the path in the use statement,
        // they will go to the definition in the imported file.
        const target = resolvePath(path, ctx);
        ctx.symbols.query({ doc: ctx.doc, node }, 'mcdoc', `${ctx.moduleIdentifier}::${identifier.value}`).ifDeclared((symbol) => reportDuplicatedDeclaration(ctx, symbol, identifier)).elseEnter({
            data: {
                subcategory: 'use_statement_binding',
                visibility: 1 /* SymbolVisibility.File */,
                data: target ? { target } : undefined,
            },
            usage: { type: 'definition', node: identifier, fullRange: node },
        });
    }
    function hoistFor(subcategory, node, destructor, getData) {
        const { docComments, identifier, keyword } = destructor(node);
        const name = identifier?.value ?? nextAnonymousIdentifier(node, ctx);
        ctx.symbols.query({ doc: ctx.doc, node }, 'mcdoc', `${ctx.moduleIdentifier}::${name}`)
            .ifDeclared((symbol) => reportDuplicatedDeclaration(ctx, symbol, identifier ?? node))
            .elseEnter({
            data: { data: getData(node), desc: DocCommentsNode.asText(docComments), subcategory },
            // If the current syntax structure is named, then the identifier node is entered as a definition;
            // otherwise, an anonymous identifier is generated for the symbol and the keyword node is entered as a definition.
            usage: {
                type: 'definition',
                node: identifier ?? keyword,
                fullRange: identifier && node,
            },
        });
    }
    function nextAnonymousIndex(node, ctx) {
        const data = ctx.symbols.query({ doc: ctx.doc, node }, 'mcdoc', ctx.moduleIdentifier).getData(ModuleSymbolData.is);
        if (!data) {
            throw new Error(`No symbol data for module '${ctx.moduleIdentifier}'`);
        }
        return data.nextAnonymousIndex++;
    }
    function nextAnonymousIdentifier(node, ctx) {
        return `<anonymous ${nextAnonymousIndex(node, ctx)}>`;
    }
}
/**
 * Bind the type param block of a parent node, and modifies the `data` argument in-place to change its `typeDef` to be of template kind.
 */
function bindTypeParamBlock(node, typeParams, data, ctx) {
    // Type parameters are added as local symbols on the type alias AST node.
    // Thus we create a new local scope on the type alias statement node first.
    node.locals = Object.create(null);
    // They are also added to the type definition.
    data.typeDef = { kind: 'template', child: data.typeDef, typeParams: [] };
    const { params } = TypeParamBlockNode.destruct(typeParams);
    for (const param of params) {
        const { identifier: paramIdentifier } = TypeParamNode.destruct(param);
        if (paramIdentifier.value) {
            // Add the type parameter as a local symbol.
            const paramPath = `${ctx.moduleIdentifier}::${paramIdentifier.value}`;
            ctx.symbols.query({ doc: ctx.doc, node }, 'mcdoc', paramPath).ifDeclared((symbol) => reportDuplicatedDeclaration(ctx, symbol, paramIdentifier)).elseEnter({
                data: { visibility: 0 /* SymbolVisibility.Block */ },
                usage: { type: 'declaration', node: paramIdentifier, fullRange: param },
            });
            // Also add it to the type definition.
            data.typeDef.typeParams.push({ path: paramPath });
        }
        // if (constraint) {
        // 	await bindPath(constraint, ctx)
        // }
    }
}
async function bindDispatchStatement(node, ctx) {
    const { attributes, location, index, target, typeParams } = DispatchStatementNode.destruct(node);
    if (!(location && index && target)) {
        return;
    }
    const locationStr = ResourceLocationNode.toString(location, 'full');
    ctx.symbols.query(ctx.doc, 'mcdoc/dispatcher', locationStr).enter({
        usage: { type: 'reference', node: location, fullRange: node },
    });
    const { parallelIndices } = IndexBodyNode.destruct(index);
    if (parallelIndices.length) {
        const data = { typeDef: convertType(target, ctx) };
        if (typeParams) {
            bindTypeParamBlock(node, typeParams, data, ctx);
        }
        appendAttributes(data.typeDef, attributes, ctx);
        for (const key of parallelIndices) {
            if (DynamicIndexNode.is(key)) {
                // Ignore dynamic indices in dispatch statements.
                continue;
            }
            ctx.symbols.query(ctx.doc, 'mcdoc/dispatcher', locationStr, asString(key)).ifDeclared((symbol) => reportDuplicatedDeclaration(ctx, symbol, key, {
                localeString: 'mcdoc.binder.dispatcher-statement.duplicated-key',
            })).elseEnter({ data: { data }, usage: { type: 'definition', node: key, fullRange: node } });
        }
    }
    await bindType(target, ctx);
}
async function bindType(node, ctx) {
    if (DispatcherTypeNode.is(node)) {
        await bindDispatcherType(node, ctx);
    }
    else if (EnumNode.is(node)) {
        bindEnum(node, ctx);
    }
    else if (ListTypeNode.is(node)) {
        const { item } = ListTypeNode.destruct(node);
        await bindType(item, ctx);
    }
    else if (ReferenceTypeNode.is(node)) {
        const { path } = ReferenceTypeNode.destruct(node);
        await bindPath(path, ctx);
    }
    else if (StructNode.is(node)) {
        await bindStruct(node, ctx);
    }
    else if (TupleTypeNode.is(node)) {
        const { items } = TupleTypeNode.destruct(node);
        for (const item of items) {
            await bindType(item, ctx);
        }
    }
    else if (UnionTypeNode.is(node)) {
        const { members } = UnionTypeNode.destruct(node);
        for (const member of members) {
            await bindType(member, ctx);
        }
    }
    const { appendixes } = TypeBaseNode.destruct(node);
    for (const appendix of appendixes) {
        if (TypeArgBlockNode.is(appendix)) {
            const { args } = TypeArgBlockNode.destruct(appendix);
            for (const arg of args) {
                await bindType(arg, ctx);
            }
        }
    }
}
async function bindDispatcherType(node, ctx) {
    const { index, location } = DispatcherTypeNode.destruct(node);
    const locationStr = ResourceLocationNode.toString(location, 'full');
    ctx.symbols.query(ctx.doc, 'mcdoc/dispatcher', locationStr).enter({
        usage: { type: 'reference', node: location, fullRange: node },
    });
    const { parallelIndices } = IndexBodyNode.destruct(index);
    for (const key of parallelIndices) {
        if (DynamicIndexNode.is(key)) {
            // Although it is technically possible to bind some of the dynamic indices as references
            // of struct keys, it is rather complicated to do so. We will ignore them for now.
            continue;
        }
        ctx.symbols.query(ctx.doc, 'mcdoc/dispatcher', locationStr, asString(key)).enter({
            usage: { type: 'reference', node: key, fullRange: node },
        });
    }
}
async function bindPath(node, ctx) {
    for (const { identifiers, node: identNode, indexRight } of resolvePathByStep(node, ctx, {
        reportErrors: true,
    })) {
        if (!identifiers?.length) {
            continue;
        }
        if (indexRight === 1) {
            // The second last identifier in a path points to a file module.
            const referencedModuleFile = pathArrayToString(identifiers);
            const referencedModuleUri = identifierToUri(referencedModuleFile, ctx);
            if (!referencedModuleUri) {
                ctx.err.report(localize('mcdoc.binder.path.unknown-module', localeQuote(referencedModuleFile)), node, ErrorSeverity.Warning);
                return;
            }
            await ctx.ensureBindingStarted(referencedModuleUri);
        }
        ctx.symbols.query({ doc: ctx.doc, node: identNode }, 'mcdoc', pathArrayToString(identifiers))
            .ifDeclared((_, query) => query.enter({
            usage: {
                type: 'reference',
                node: identNode,
                fullRange: node,
                skipRenaming: LiteralNode.is(identNode),
            },
        })).else(() => {
            if (indexRight === 0) {
                ctx.err.report(localize('mcdoc.binder.path.unknown-identifier', localeQuote(atArray(identifiers, -1)), localeQuote(pathArrayToString(identifiers.slice(0, -1)))), node, ErrorSeverity.Warning);
            }
        });
    }
}
function bindEnum(node, ctx) {
    const { block, identifier, keyword } = EnumNode.destruct(node);
    const symbol = identifier?.symbol ?? keyword.symbol;
    if (symbol?.subcategory !== 'enum') {
        return;
    }
    const query = ctx.symbols.query({ doc: ctx.doc, node }, 'mcdoc', ...symbol.path);
    Dev.assertDefined(query.symbol);
    bindEnumBlock(block, ctx, query);
}
function bindEnumBlock(node, ctx, query, options = {}) {
    const { fields } = EnumBlockNode.destruct(node);
    for (const field of fields) {
        const { identifier } = EnumFieldNode.destruct(field);
        query.member(identifier.value, (fieldQuery) => fieldQuery.ifDeclared((symbol) => reportDuplicatedDeclaration(ctx, symbol, identifier))
            .elseEnter({ usage: { type: 'definition', node: identifier, fullRange: field } }));
    }
}
async function bindInjection(node, ctx) {
    const { injection } = InjectionNode.destruct(node);
    if (EnumInjectionNode.is(injection)) {
        // TODO
        // const {  } = EnumInjectionNode.destruct(injection)
        // bindEnumBlock(block, ctx, query, { extendsTypeDefData: true })
    }
}
async function bindStruct(node, ctx) {
    const { block, identifier, keyword } = StructNode.destruct(node);
    const symbol = identifier?.symbol ?? keyword.symbol;
    if (symbol?.subcategory !== 'struct') {
        return;
    }
    const query = ctx.symbols.query({ doc: ctx.doc, node }, 'mcdoc', ...symbol.path);
    Dev.assertDefined(query.symbol);
    await bindStructBlock(block, ctx, query);
}
async function bindStructBlock(node, ctx, query, options = {}) {
    const { fields } = StructBlockNode.destruct(node);
    for (const field of fields) {
        if (StructPairFieldNode.is(field)) {
            const { key, type } = StructPairFieldNode.destruct(field);
            if (!StructMapKeyNode.is(key)) {
                query.member(key.value, (fieldQuery) => fieldQuery.ifDeclared((symbol) => reportDuplicatedDeclaration(ctx, symbol, key))
                    .elseEnter({ usage: { type: 'definition', node: key, fullRange: field } }));
            }
            await bindType(type, ctx);
        }
        else {
            const { type } = StructSpreadFieldNode.destruct(field);
            await bindType(type, ctx);
        }
    }
}
async function bindTypeAlias(node, ctx) {
    const { identifier, rhs, typeParams } = TypeAliasNode.destruct(node);
    if (!identifier?.value) {
        return;
    }
    if (rhs) {
        await bindType(rhs, ctx);
    }
}
async function bindUseStatement(node, ctx) {
    const { path } = UseStatementNode.destruct(node);
    if (!path) {
        return;
    }
    return bindPath(path, ctx);
}
export function registerMcdocBinders(meta) {
    meta.registerBinder('mcdoc:module', fileModule);
}
function reportDuplicatedDeclaration(ctx, symbol, range, options = { localeString: 'mcdoc.binder.duplicated-declaration' }) {
    ctx.err.report(localize(options.localeString, localeQuote(symbol.identifier)), range, ErrorSeverity.Warning, {
        related: [{
                location: SymbolUtil.getDeclaredLocation(symbol),
                message: localize(`${options.localeString}.related`, localeQuote(symbol.identifier)),
            }],
    });
}
function* resolvePathByStep(path, ctx, options = {}) {
    const { children, isAbsolute } = PathNode.destruct(path);
    let identifiers = isAbsolute ? [] : pathStringToArray(ctx.moduleIdentifier);
    for (const [i, child] of children.entries()) {
        const indexRight = children.length - 1 - i;
        switch (child.type) {
            case 'mcdoc:identifier':
                // For a path node with `n` children, the first `n-1` child nodes specify
                // the path of the module that contains the symbol. They will be pushed
                // to the `identifiers` array and yielded as-is. The last node, however,
                // may be created by a use statement and points to a global symbol
                // in a different file. We will query the symbol table and rewrite
                // the `identifiers` array to be the target path if needed.
                identifiers.push(child.value);
                if (indexRight === 0) {
                    ctx.symbols.query({ doc: ctx.doc, node: child }, 'mcdoc', pathArrayToString(identifiers)).ifDeclared((symbol) => {
                        const data = symbol.data;
                        if (data?.target) {
                            identifiers = [...data.target];
                        }
                    });
                }
                break;
            case 'mcdoc:literal':
                // super
                if (identifiers.length === 0) {
                    if (options.reportErrors) {
                        ctx.err.report(localize('mcdoc.binder.path.super-from-root'), child);
                    }
                    return;
                }
                identifiers.pop();
                break;
            default:
                Dev.assertNever(child);
        }
        yield { identifiers, node: child, index: i, indexRight };
    }
}
function resolvePath(path, ctx, options = {}) {
    return atArray([...resolvePathByStep(path, ctx, options)], -1)?.identifiers;
}
function identifierToUri(module, ctx) {
    return ctx.symbols.global.mcdoc?.[module]?.definition?.[0]?.uri;
}
function uriToIdentifier(uri, ctx) {
    return Object.values(ctx.symbols.global.mcdoc ?? {}).find((symbol) => {
        return (symbol.subcategory === 'module' && symbol.definition?.some((loc) => loc.uri === uri));
    })?.identifier;
}
function pathArrayToString(path) {
    return path ? `::${path.join('::')}` : undefined;
}
function pathStringToArray(path) {
    if (!path.startsWith('::')) {
        throw new Error('Only absolute paths are supported');
    }
    return path.slice(2).split('::');
}
function convertType(node, ctx) {
    switch (node.type) {
        case 'mcdoc:enum':
            return convertEnum(node, ctx);
        case 'mcdoc:struct':
            return convertStruct(node, ctx);
        case 'mcdoc:type/any':
            return convertAny(node, ctx);
        case 'mcdoc:type/boolean':
            return convertBoolean(node, ctx);
        case 'mcdoc:type/dispatcher':
            return convertDispatcher(node, ctx);
        case 'mcdoc:type/list':
            return convertList(node, ctx);
        case 'mcdoc:type/literal':
            return convertLiteral(node, ctx);
        case 'mcdoc:type/numeric_type':
            return convertNumericType(node, ctx);
        case 'mcdoc:type/primitive_array':
            return convertPrimitiveArray(node, ctx);
        case 'mcdoc:type/string':
            return convertString(node, ctx);
        case 'mcdoc:type/reference':
            return convertReference(node, ctx);
        case 'mcdoc:type/tuple':
            return convertTuple(node, ctx);
        case 'mcdoc:type/union':
            return convertUnion(node, ctx);
        default:
            return Dev.assertNever(node);
    }
}
function wrapType(node, type, ctx, options = {}) {
    const { attributes, appendixes } = TypeBaseNode.destruct(node);
    let ans = type;
    for (const appendix of appendixes) {
        if (IndexBodyNode.is(appendix)) {
            if (options.skipFirstIndexBody) {
                options.skipFirstIndexBody = false;
                continue;
            }
            ans = { kind: 'indexed', child: ans, parallelIndices: convertIndexBody(appendix, ctx) };
        }
        else {
            ans = { kind: 'concrete', child: ans, typeArgs: convertTypeArgBlock(appendix, ctx) };
        }
    }
    ans.attributes = convertAttributes(attributes, ctx);
    return ans;
}
function appendAttributes(typeDef, attributes, ctx) {
    const convertedAttributes = convertAttributes(attributes, ctx);
    if (convertedAttributes) {
        if (typeDef.attributes) {
            typeDef.attributes = [...typeDef.attributes, ...convertedAttributes];
        }
        else {
            typeDef.attributes = convertedAttributes;
        }
    }
}
function convertAttributes(nodes, ctx) {
    return undefineEmptyArray(nodes.map((n) => convertAttribute(n, ctx)));
}
function undefineEmptyArray(array) {
    return array.length ? array : undefined;
}
function convertAttribute(node, ctx) {
    const { name, value } = AttributeNode.destruct(node);
    return { name: name.value, value: value && convertAttributeValue(value, ctx) };
}
function convertAttributeValue(node, ctx) {
    if (node.type === 'mcdoc:attribute/tree') {
        return { kind: 'tree', values: convertAttributeTree(node, ctx) };
    }
    else {
        return convertType(node, ctx);
    }
}
function convertAttributeTree(node, ctx) {
    const ans = {};
    const { named, positional } = AttributeTreeNode.destruct(node);
    if (positional) {
        const { values } = AttributeTreePosValuesNode.destruct(positional);
        for (const [i, child] of values.entries()) {
            ans[i] = convertAttributeValue(child, ctx);
        }
    }
    if (named) {
        const { values } = AttributeTreeNamedValuesNode.destruct(named);
        for (const { key, value } of values) {
            ans[key.value] = convertAttributeValue(value, ctx);
        }
    }
    return ans;
}
function convertIndexBodies(nodes, ctx) {
    return undefineEmptyArray(nodes.map((n) => convertIndexBody(n, ctx)));
}
function convertIndexBody(node, ctx) {
    const { parallelIndices } = IndexBodyNode.destruct(node);
    return parallelIndices.map((n) => convertIndex(n, ctx));
}
function convertIndex(node, ctx) {
    return StaticIndexNode.is(node) ? convertStaticIndex(node, ctx) : convertDynamicIndex(node, ctx);
}
function convertStaticIndex(node, ctx) {
    return { kind: 'static', value: asString(node) };
}
function convertDynamicIndex(node, ctx) {
    const { keys } = DynamicIndexNode.destruct(node);
    return {
        kind: 'dynamic',
        accessor: keys.map(key => {
            if (LiteralNode.is(key) && key.value.startsWith('%')) {
                return { keyword: key.value.slice(1) };
            }
            return asString(key);
        }),
    };
}
function convertTypeArgBlock(node, ctx) {
    const { args } = TypeArgBlockNode.destruct(node);
    return args.map((a) => convertType(a, ctx));
}
function convertEnum(node, ctx) {
    const { block, enumKind, identifier } = EnumNode.destruct(node);
    // Return reference if the enum has been hoisted
    if (identifier && !ctx.isHoisting) {
        return wrapType(node, {
            kind: 'reference',
            path: `${ctx.moduleIdentifier}::${identifier.value}`,
        }, ctx);
    }
    // Shortcut if the typeDef has been added to the enum symbol.
    const symbol = identifier?.symbol ?? node.symbol;
    if (symbol && TypeDefSymbolData.is(symbol.data) && symbol.data.typeDef.kind === 'enum') {
        return symbol.data.typeDef;
    }
    return wrapType(node, { kind: 'enum', enumKind, values: convertEnumBlock(block, ctx) }, ctx);
}
function convertEnumBlock(node, ctx) {
    const { fields } = EnumBlockNode.destruct(node);
    return fields.map((n) => convertEnumField(n, ctx));
}
function convertEnumField(node, ctx) {
    const { attributes, docComments, identifier, value } = EnumFieldNode.destruct(node);
    return {
        attributes: convertAttributes(attributes, ctx),
        desc: DocCommentsNode.asText(docComments),
        identifier: identifier.value,
        value: convertEnumValue(value, ctx),
    };
}
function convertEnumValue(node, ctx) {
    if (TypedNumberNode.is(node)) {
        const { value } = TypedNumberNode.destruct(node);
        return value.value;
    }
    return node.value;
}
function convertStruct(node, ctx) {
    const { block, identifier } = StructNode.destruct(node);
    // Return reference if the struct has been hoisted
    if (identifier && !ctx.isHoisting) {
        return wrapType(node, {
            kind: 'reference',
            path: `${ctx.moduleIdentifier}::${identifier.value}`,
        }, ctx);
    }
    // Shortcut if the typeDef has been added to the struct symbol.
    const symbol = identifier?.symbol ?? node.symbol;
    if (symbol && TypeDefSymbolData.is(symbol.data) && symbol.data.typeDef.kind === 'struct') {
        return symbol.data.typeDef;
    }
    return wrapType(node, { kind: 'struct', fields: convertStructBlock(block, ctx) }, ctx);
}
function convertStructBlock(node, ctx) {
    const { fields } = StructBlockNode.destruct(node);
    return fields.map((n) => convertStructField(n, ctx));
}
function convertStructField(node, ctx) {
    return StructPairFieldNode.is(node)
        ? convertStructPairField(node, ctx)
        : convertStructSpreadField(node, ctx);
}
function convertStructPairField(node, ctx) {
    const { attributes, docComments, key, type, isOptional } = StructPairFieldNode.destruct(node);
    return {
        kind: 'pair',
        attributes: convertAttributes(attributes, ctx),
        desc: DocCommentsNode.asText(docComments),
        key: convertStructKey(key, ctx),
        type: convertType(type, ctx),
        optional: isOptional,
    };
}
function convertStructKey(node, ctx) {
    if (StructMapKeyNode.is(node)) {
        const { type } = StructMapKeyNode.destruct(node);
        return convertType(type, ctx);
    }
    else {
        return asString(node);
    }
}
function convertStructSpreadField(node, ctx) {
    const { attributes, type } = StructSpreadFieldNode.destruct(node);
    return {
        kind: 'spread',
        attributes: convertAttributes(attributes, ctx),
        type: convertType(type, ctx),
    };
}
function convertAny(node, ctx) {
    return wrapType(node, { kind: 'any' }, ctx);
}
function convertBoolean(node, ctx) {
    return wrapType(node, { kind: 'boolean' }, ctx);
}
function convertDispatcher(node, ctx) {
    const { index, location } = DispatcherTypeNode.destruct(node);
    return wrapType(node, {
        kind: 'dispatcher',
        parallelIndices: convertIndexBody(index, ctx),
        registry: ResourceLocationNode.toString(location, 'full'),
    }, ctx, { skipFirstIndexBody: true });
}
function convertList(node, ctx) {
    const { item, lengthRange } = ListTypeNode.destruct(node);
    return wrapType(node, {
        kind: 'list',
        item: convertType(item, ctx),
        lengthRange: convertRange(lengthRange, ctx),
    }, ctx);
}
function convertRange(node, ctx) {
    if (!node) {
        return undefined;
    }
    const { kind, min, max } = FloatRangeNode.is(node)
        ? FloatRangeNode.destruct(node)
        : IntRangeNode.destruct(node);
    return { kind, min: min?.value, max: max?.value };
}
function convertLiteral(node, ctx) {
    const { value } = LiteralTypeNode.destruct(node);
    return wrapType(node, { kind: 'literal', value: convertLiteralValue(value, ctx) }, ctx);
}
function convertLiteralValue(node, ctx) {
    if (LiteralNode.is(node)) {
        return { kind: 'boolean', value: node.value === 'true' };
    }
    else if (TypedNumberNode.is(node)) {
        const { suffix, value } = TypedNumberNode.destruct(node);
        return {
            kind: convertLiteralNumberSuffix(suffix, ctx)
                ?? (value.type === 'integer' ? 'int' : 'double'),
            value: value.value,
        };
    }
    else {
        return { kind: 'string', value: node.value };
    }
}
function convertLiteralNumberSuffix(node, ctx) {
    const suffix = node?.value;
    switch (suffix?.toLowerCase()) {
        case 'b':
            return 'byte';
        case 's':
            return 'short';
        case 'l':
            return 'long';
        case 'f':
            return 'float';
        case 'd':
            return 'double';
        default:
            return undefined;
    }
}
function convertNumericType(node, ctx) {
    const { numericKind, valueRange } = NumericTypeNode.destruct(node);
    return wrapType(node, {
        kind: numericKind.value,
        valueRange: convertRange(valueRange, ctx),
    }, ctx);
}
function convertPrimitiveArray(node, ctx) {
    const { arrayKind, lengthRange, valueRange } = PrimitiveArrayTypeNode.destruct(node);
    return wrapType(node, {
        kind: `${arrayKind.value}_array`,
        lengthRange: convertRange(lengthRange, ctx),
        valueRange: convertRange(valueRange, ctx),
    }, ctx);
}
function convertString(node, ctx) {
    const { lengthRange } = StringTypeNode.destruct(node);
    return wrapType(node, { kind: 'string', lengthRange: convertRange(lengthRange, ctx) }, ctx);
}
function convertReference(node, ctx) {
    const { path } = ReferenceTypeNode.destruct(node);
    return wrapType(node, { kind: 'reference', path: pathArrayToString(resolvePath(path, ctx)) }, ctx);
}
function convertTuple(node, ctx) {
    const { items } = TupleTypeNode.destruct(node);
    return wrapType(node, { kind: 'tuple', items: items.map((n) => convertType(n, ctx)) }, ctx);
}
function convertUnion(node, ctx) {
    const { members } = UnionTypeNode.destruct(node);
    return wrapType(node, { kind: 'union', members: members.map((n) => convertType(n, ctx)) }, ctx);
}
function asString(node) {
    if (ResourceLocationNode.is(node)) {
        return ResourceLocationNode.toString(node, 'short');
    }
    return node.value;
}
//# sourceMappingURL=index.js.map