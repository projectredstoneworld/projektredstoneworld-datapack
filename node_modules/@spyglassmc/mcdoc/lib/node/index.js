import { atArray, CommentNode, FloatNode, IntegerNode, ResourceLocationNode, StringNode, } from '@spyglassmc/core';
export var ModuleNode;
(function (ModuleNode) {
    function is(node) {
        return node?.type === 'mcdoc:module';
    }
    ModuleNode.is = is;
})(ModuleNode || (ModuleNode = {}));
export var TopLevelNode;
(function (TopLevelNode) {
    function is(node) {
        return (CommentNode.is(node)
            || DispatchStatementNode.is(node)
            || EnumNode.is(node)
            || InjectionNode.is(node)
            || StructNode.is(node)
            || TypeAliasNode.is(node)
            || UseStatementNode.is(node));
    }
    TopLevelNode.is = is;
})(TopLevelNode || (TopLevelNode = {}));
export var DispatchStatementNode;
(function (DispatchStatementNode) {
    function destruct(node) {
        return {
            attributes: node.children.filter(AttributeNode.is),
            location: node.children.find(ResourceLocationNode.is),
            index: node.children.find(IndexBodyNode.is),
            target: node.children.find(TypeNode.is),
            typeParams: node.children.find(TypeParamBlockNode.is),
        };
    }
    DispatchStatementNode.destruct = destruct;
    function is(node) {
        return (node?.type === 'mcdoc:dispatch_statement');
    }
    DispatchStatementNode.is = is;
})(DispatchStatementNode || (DispatchStatementNode = {}));
export var LiteralNode;
(function (LiteralNode) {
    function is(node) {
        return node?.type === 'mcdoc:literal';
    }
    LiteralNode.is = is;
})(LiteralNode || (LiteralNode = {}));
export var IndexBodyNode;
(function (IndexBodyNode) {
    function destruct(node) {
        return { parallelIndices: node.children.filter(IndexNode.is) };
    }
    IndexBodyNode.destruct = destruct;
    function is(node) {
        return node?.type === 'mcdoc:index_body';
    }
    IndexBodyNode.is = is;
})(IndexBodyNode || (IndexBodyNode = {}));
export var IndexNode;
(function (IndexNode) {
    function is(node) {
        return StaticIndexNode.is(node) || DynamicIndexNode.is(node);
    }
    IndexNode.is = is;
})(IndexNode || (IndexNode = {}));
export var StaticIndexNode;
(function (StaticIndexNode) {
    function is(node) {
        return (LiteralNode.is(node)
            || IdentifierNode.is(node)
            || StringNode.is(node)
            || ResourceLocationNode.is(node));
    }
    StaticIndexNode.is = is;
})(StaticIndexNode || (StaticIndexNode = {}));
export var IdentifierNode;
(function (IdentifierNode) {
    function is(node) {
        return node?.type === 'mcdoc:identifier';
    }
    IdentifierNode.is = is;
})(IdentifierNode || (IdentifierNode = {}));
export var DynamicIndexNode;
(function (DynamicIndexNode) {
    function destruct(node) {
        return { keys: node.children.filter(AccessorKeyNode.is) };
    }
    DynamicIndexNode.destruct = destruct;
    function is(node) {
        return (node?.type === 'mcdoc:dynamic_index');
    }
    DynamicIndexNode.is = is;
})(DynamicIndexNode || (DynamicIndexNode = {}));
export var AccessorKeyNode;
(function (AccessorKeyNode) {
    function is(node) {
        return (LiteralNode.is(node) || IdentifierNode.is(node) || StringNode.is(node));
    }
    AccessorKeyNode.is = is;
})(AccessorKeyNode || (AccessorKeyNode = {}));
export var TypeNode;
(function (TypeNode) {
    function is(node) {
        return (AnyTypeNode.is(node)
            || BooleanTypeNode.is(node)
            || StringTypeNode.is(node)
            || LiteralTypeNode.is(node)
            || NumericTypeNode.is(node)
            || PrimitiveArrayTypeNode.is(node)
            || ListTypeNode.is(node)
            || TupleTypeNode.is(node)
            || EnumNode.is(node)
            || StructNode.is(node)
            || ReferenceTypeNode.is(node)
            || DispatcherTypeNode.is(node)
            || UnionTypeNode.is(node));
    }
    TypeNode.is = is;
})(TypeNode || (TypeNode = {}));
export var TypeBaseNode;
(function (TypeBaseNode) {
    function destruct(node) {
        return {
            appendixes: node.children.filter((n) => IndexBodyNode.is(n) || TypeArgBlockNode.is(n)),
            attributes: node.children.filter(AttributeNode.is),
        };
    }
    TypeBaseNode.destruct = destruct;
})(TypeBaseNode || (TypeBaseNode = {}));
export var AttributeNode;
(function (AttributeNode) {
    function destruct(node) {
        return {
            name: node.children.find(IdentifierNode.is),
            value: node.children.find(AttributeValueNode.is),
        };
    }
    AttributeNode.destruct = destruct;
    function is(node) {
        return node?.type === 'mcdoc:attribute';
    }
    AttributeNode.is = is;
})(AttributeNode || (AttributeNode = {}));
export var AttributeValueNode;
(function (AttributeValueNode) {
    function is(node) {
        return TypeNode.is(node) || AttributeTreeNode.is(node);
    }
    AttributeValueNode.is = is;
})(AttributeValueNode || (AttributeValueNode = {}));
export var AttributeTreeNode;
(function (AttributeTreeNode) {
    function destruct(node) {
        return {
            positional: node.children.find(AttributeTreePosValuesNode.is),
            named: node.children.find(AttributeTreeNamedValuesNode.is),
        };
    }
    AttributeTreeNode.destruct = destruct;
    function is(node) {
        return (node?.type === 'mcdoc:attribute/tree');
    }
    AttributeTreeNode.is = is;
})(AttributeTreeNode || (AttributeTreeNode = {}));
export var AttributeTreePosValuesNode;
(function (AttributeTreePosValuesNode) {
    function destruct(node) {
        return { values: node.children.filter(AttributeValueNode.is) };
    }
    AttributeTreePosValuesNode.destruct = destruct;
    function is(node) {
        return (node?.type === 'mcdoc:attribute/tree/pos');
    }
    AttributeTreePosValuesNode.is = is;
})(AttributeTreePosValuesNode || (AttributeTreePosValuesNode = {}));
export var AttributeTreeNamedValuesNode;
(function (AttributeTreeNamedValuesNode) {
    function destruct(node) {
        const ans = { values: [] };
        let key;
        for (const child of node.children) {
            if (CommentNode.is(child)) {
                continue;
            }
            if (IdentifierNode.is(child) || StringNode.is(child)) {
                key = child;
            }
            else if (key) {
                ans.values.push({ key, value: child });
                key = undefined;
            }
        }
        return ans;
    }
    AttributeTreeNamedValuesNode.destruct = destruct;
    function is(node) {
        return (node?.type
            === 'mcdoc:attribute/tree/named');
    }
    AttributeTreeNamedValuesNode.is = is;
})(AttributeTreeNamedValuesNode || (AttributeTreeNamedValuesNode = {}));
export var TypeArgBlockNode;
(function (TypeArgBlockNode) {
    function destruct(node) {
        return { args: node.children.filter(TypeNode.is) };
    }
    TypeArgBlockNode.destruct = destruct;
    function is(node) {
        return (node?.type === 'mcdoc:type_arg_block');
    }
    TypeArgBlockNode.is = is;
})(TypeArgBlockNode || (TypeArgBlockNode = {}));
export var AnyTypeNode;
(function (AnyTypeNode) {
    function is(node) {
        return node?.type === 'mcdoc:type/any';
    }
    AnyTypeNode.is = is;
})(AnyTypeNode || (AnyTypeNode = {}));
export var BooleanTypeNode;
(function (BooleanTypeNode) {
    function is(node) {
        return node?.type === 'mcdoc:type/boolean';
    }
    BooleanTypeNode.is = is;
})(BooleanTypeNode || (BooleanTypeNode = {}));
export var IntRangeNode;
(function (IntRangeNode) {
    function destruct(node) {
        return destructRangeNode(node);
    }
    IntRangeNode.destruct = destruct;
    function is(node) {
        return node?.type === 'mcdoc:int_range';
    }
    IntRangeNode.is = is;
})(IntRangeNode || (IntRangeNode = {}));
export var LiteralTypeNode;
(function (LiteralTypeNode) {
    function destruct(node) {
        return { value: node.children.find(LiteralTypeValueNode.is) };
    }
    LiteralTypeNode.destruct = destruct;
    function is(node) {
        return node?.type === 'mcdoc:type/literal';
    }
    LiteralTypeNode.is = is;
})(LiteralTypeNode || (LiteralTypeNode = {}));
export var LiteralTypeValueNode;
(function (LiteralTypeValueNode) {
    function is(node) {
        return (LiteralNode.is(node) || TypedNumberNode.is(node) || StringNode.is(node));
    }
    LiteralTypeValueNode.is = is;
})(LiteralTypeValueNode || (LiteralTypeValueNode = {}));
export var TypedNumberNode;
(function (TypedNumberNode) {
    function destruct(node) {
        return {
            value: node.children.find(FloatNode.is) ?? node.children.find(IntegerNode.is),
            suffix: node.children.find(LiteralNode.is),
        };
    }
    TypedNumberNode.destruct = destruct;
    function is(node) {
        return node?.type === 'mcdoc:typed_number';
    }
    TypedNumberNode.is = is;
})(TypedNumberNode || (TypedNumberNode = {}));
export var NumericTypeNode;
(function (NumericTypeNode) {
    function destruct(node) {
        return {
            numericKind: node.children.find(LiteralNode.is),
            valueRange: node.children.find(FloatRangeNode.is) || node.children.find(IntRangeNode.is),
        };
    }
    NumericTypeNode.destruct = destruct;
    function is(node) {
        return (node?.type === 'mcdoc:type/numeric_type');
    }
    NumericTypeNode.is = is;
})(NumericTypeNode || (NumericTypeNode = {}));
export const RangeExclusiveChar = '<';
export var RangeKind;
(function (RangeKind) {
    function isLeftExclusive(rangeKind) {
        return (rangeKind & 0b10) !== 0;
    }
    RangeKind.isLeftExclusive = isLeftExclusive;
    function isRightExclusive(rangeKind) {
        return (rangeKind & 0b01) !== 0;
    }
    RangeKind.isRightExclusive = isRightExclusive;
})(RangeKind || (RangeKind = {}));
export function getRangeDelimiter(kind) {
    const prefix = kind & 0b10 ? RangeExclusiveChar : '';
    const suffix = kind & 0b01 ? RangeExclusiveChar : '';
    return `${prefix}..${suffix}`;
}
function destructRangeNode(node) {
    let kind;
    let min;
    let max;
    if (node.children.length === 1) {
        // a
        kind = 0b00;
        min = max = node.children[0];
    }
    else if (node.children.length === 3) {
        // a..b
        kind = getKind(node.children[1]);
        min = node.children[0];
        max = node.children[2];
    }
    else if (LiteralNode.is(node.children[0])) {
        // ..b
        kind = getKind(node.children[0]);
        max = node.children[1];
    }
    else {
        // a..
        kind = getKind(node.children[1]);
        min = node.children[0];
    }
    return { kind, min, max };
    function getKind(delimiter) {
        let ans = 0b00;
        if (delimiter.value.startsWith(RangeExclusiveChar)) {
            ans |= 0b10;
        }
        if (delimiter.value.endsWith(RangeExclusiveChar)) {
            ans |= 0b01;
        }
        return ans;
    }
}
export var FloatRangeNode;
(function (FloatRangeNode) {
    function destruct(node) {
        return destructRangeNode(node);
    }
    FloatRangeNode.destruct = destruct;
    function is(node) {
        return node?.type === 'mcdoc:float_range';
    }
    FloatRangeNode.is = is;
})(FloatRangeNode || (FloatRangeNode = {}));
export var PrimitiveArrayTypeNode;
(function (PrimitiveArrayTypeNode) {
    function destruct(node) {
        let lengthRange;
        let valueRange;
        let afterBrackets = false;
        for (const child of node.children) {
            if (LiteralNode.is(child) && child.value === '[]') {
                afterBrackets = true;
            }
            else if (IntRangeNode.is(child)) {
                if (afterBrackets) {
                    lengthRange = child;
                }
                else {
                    valueRange = child;
                }
            }
        }
        return { arrayKind: node.children.find(LiteralNode.is), lengthRange, valueRange };
    }
    PrimitiveArrayTypeNode.destruct = destruct;
    function is(node) {
        return (node?.type === 'mcdoc:type/primitive_array');
    }
    PrimitiveArrayTypeNode.is = is;
})(PrimitiveArrayTypeNode || (PrimitiveArrayTypeNode = {}));
export var ListTypeNode;
(function (ListTypeNode) {
    function destruct(node) {
        return {
            item: node.children.find(TypeNode.is),
            lengthRange: node.children.find(IntRangeNode.is),
        };
    }
    ListTypeNode.destruct = destruct;
    function is(node) {
        return node?.type === 'mcdoc:type/list';
    }
    ListTypeNode.is = is;
})(ListTypeNode || (ListTypeNode = {}));
export var StringTypeNode;
(function (StringTypeNode) {
    function destruct(node) {
        return { lengthRange: node.children.find(IntRangeNode.is) };
    }
    StringTypeNode.destruct = destruct;
    function is(node) {
        return node?.type === 'mcdoc:type/string';
    }
    StringTypeNode.is = is;
})(StringTypeNode || (StringTypeNode = {}));
export var TupleTypeNode;
(function (TupleTypeNode) {
    function destruct(node) {
        return { items: node.children.filter(TypeNode.is) };
    }
    TupleTypeNode.destruct = destruct;
    function is(node) {
        return node?.type === 'mcdoc:type/tuple';
    }
    TupleTypeNode.is = is;
})(TupleTypeNode || (TupleTypeNode = {}));
export var EnumNode;
(function (EnumNode) {
    EnumNode.Kinds = new Set(['byte', 'short', 'int', 'long', 'float', 'double', 'string']);
    function destruct(node) {
        return {
            block: node.children.find(EnumBlockNode.is),
            docComments: node.children.find(DocCommentsNode.is),
            enumKind: getEnumKind(node),
            identifier: node.children.find(IdentifierNode.is),
            keyword: node.children.find(LiteralNode.is),
        };
        function getEnumKind(node) {
            for (const literal of node.children.filter(LiteralNode.is)) {
                if (EnumNode.Kinds.has(literal.value)) {
                    return literal.value;
                }
            }
            return undefined;
        }
    }
    EnumNode.destruct = destruct;
    function is(node) {
        return node?.type === 'mcdoc:enum';
    }
    EnumNode.is = is;
})(EnumNode || (EnumNode = {}));
export var DocCommentsNode;
(function (DocCommentsNode) {
    /**
     * @returns The text content of this doc comment block.
     *
     * If every line contains a leading space or is empty, stripe the leading spaces off.
     * Trailing whitespace characters at the end are removed.
     *
     * e.g., given
     * ```
     * /// This is an example doc comment.
     * ///
     * /// Another line.
     * ```
     *
     * "This is an example doc comment.\n\nAnother line." is returned.
     */
    function asText(node) {
        if (!node) {
            return undefined;
        }
        let comments = node.children.map((doc) => doc.comment);
        // Note that each comment node includes the ending newline character.
        if (comments.every((s) => !s.trim() || s.startsWith(' '))) {
            comments = comments.map((s) => s.replace(/^ /, ''));
        }
        return comments.join('').trimEnd();
    }
    DocCommentsNode.asText = asText;
    function is(node) {
        return node?.type === 'mcdoc:doc_comments';
    }
    DocCommentsNode.is = is;
})(DocCommentsNode || (DocCommentsNode = {}));
export var EnumBlockNode;
(function (EnumBlockNode) {
    function destruct(node) {
        return { fields: node.children.filter(EnumFieldNode.is) };
    }
    EnumBlockNode.destruct = destruct;
    function is(node) {
        return node?.type === 'mcdoc:enum/block';
    }
    EnumBlockNode.is = is;
})(EnumBlockNode || (EnumBlockNode = {}));
export var EnumFieldNode;
(function (EnumFieldNode) {
    function destruct(node) {
        return {
            attributes: node.children.filter(AttributeNode.is),
            docComments: node.children.find(DocCommentsNode.is),
            identifier: node.children.find(IdentifierNode.is),
            value: node.children.find(EnumValueNode.is),
        };
    }
    EnumFieldNode.destruct = destruct;
    function is(node) {
        return node?.type === 'mcdoc:enum/field';
    }
    EnumFieldNode.is = is;
})(EnumFieldNode || (EnumFieldNode = {}));
export var EnumValueNode;
(function (EnumValueNode) {
    function is(node) {
        return TypedNumberNode.is(node) || StringNode.is(node);
    }
    EnumValueNode.is = is;
})(EnumValueNode || (EnumValueNode = {}));
export var PrelimNode;
(function (PrelimNode) {
    function is(node) {
        return AttributeNode.is(node) || DocCommentsNode.is(node);
    }
    PrelimNode.is = is;
})(PrelimNode || (PrelimNode = {}));
export var StructNode;
(function (StructNode) {
    function destruct(node) {
        return {
            block: node.children.find(StructBlockNode.is),
            docComments: node.children.find(DocCommentsNode.is),
            identifier: node.children.find(IdentifierNode.is),
            keyword: node.children.find(LiteralNode.is),
        };
    }
    StructNode.destruct = destruct;
    function is(node) {
        return node?.type === 'mcdoc:struct';
    }
    StructNode.is = is;
})(StructNode || (StructNode = {}));
export var ReferenceTypeNode;
(function (ReferenceTypeNode) {
    function destruct(node) {
        return { path: node.children.find(PathNode.is) };
    }
    ReferenceTypeNode.destruct = destruct;
    function is(node) {
        return (node?.type === 'mcdoc:type/reference');
    }
    ReferenceTypeNode.is = is;
})(ReferenceTypeNode || (ReferenceTypeNode = {}));
export var TypeParamBlockNode;
(function (TypeParamBlockNode) {
    function destruct(node) {
        return { params: node.children.filter(TypeParamNode.is) };
    }
    TypeParamBlockNode.destruct = destruct;
    function is(node) {
        return (node?.type === 'mcdoc:type_param_block');
    }
    TypeParamBlockNode.is = is;
})(TypeParamBlockNode || (TypeParamBlockNode = {}));
export var TypeParamNode;
(function (TypeParamNode) {
    function destruct(node) {
        return {
            // constraint: node.children.find(TypeNode.is),
            identifier: node.children.find(IdentifierNode.is),
        };
    }
    TypeParamNode.destruct = destruct;
    function is(node) {
        return node?.type === 'mcdoc:type_param';
    }
    TypeParamNode.is = is;
})(TypeParamNode || (TypeParamNode = {}));
export var PathNode;
(function (PathNode) {
    function destruct(node) {
        const lastChild = atArray(node?.children, -1);
        return {
            children: node?.children ?? [],
            isAbsolute: node?.isAbsolute,
            lastIdentifier: IdentifierNode.is(lastChild) ? lastChild : undefined,
        };
    }
    PathNode.destruct = destruct;
    function is(node) {
        return node?.type === 'mcdoc:path';
    }
    PathNode.is = is;
})(PathNode || (PathNode = {}));
export var StructBlockNode;
(function (StructBlockNode) {
    function destruct(node) {
        return { fields: node.children.filter(StructFieldNode.is) };
    }
    StructBlockNode.destruct = destruct;
    function is(node) {
        return node?.type === 'mcdoc:struct/block';
    }
    StructBlockNode.is = is;
})(StructBlockNode || (StructBlockNode = {}));
export var StructFieldNode;
(function (StructFieldNode) {
    function is(node) {
        return StructPairFieldNode.is(node) || StructSpreadFieldNode.is(node);
    }
    StructFieldNode.is = is;
})(StructFieldNode || (StructFieldNode = {}));
export var StructPairFieldNode;
(function (StructPairFieldNode) {
    function destruct(node) {
        return {
            attributes: node.children.filter(AttributeNode.is),
            docComments: node.children.find(DocCommentsNode.is),
            key: node.children.find(StructKeyNode.is),
            type: node.children.find(TypeNode.is),
            isOptional: node.isOptional,
        };
    }
    StructPairFieldNode.destruct = destruct;
    function is(node) {
        return (node?.type === 'mcdoc:struct/field/pair');
    }
    StructPairFieldNode.is = is;
})(StructPairFieldNode || (StructPairFieldNode = {}));
export var StructKeyNode;
(function (StructKeyNode) {
    function is(node) {
        return (StringNode.is(node) || IdentifierNode.is(node) || StructMapKeyNode.is(node));
    }
    StructKeyNode.is = is;
})(StructKeyNode || (StructKeyNode = {}));
export var StructMapKeyNode;
(function (StructMapKeyNode) {
    function destruct(node) {
        return { type: node.children.find(TypeNode.is) };
    }
    StructMapKeyNode.destruct = destruct;
    function is(node) {
        return (node?.type === 'mcdoc:struct/map_key');
    }
    StructMapKeyNode.is = is;
})(StructMapKeyNode || (StructMapKeyNode = {}));
export var StructSpreadFieldNode;
(function (StructSpreadFieldNode) {
    function destruct(node) {
        return {
            attributes: node.children.filter(AttributeNode.is),
            type: node.children.find(TypeNode.is),
        };
    }
    StructSpreadFieldNode.destruct = destruct;
    function is(node) {
        return (node?.type === 'mcdoc:struct/field/spread');
    }
    StructSpreadFieldNode.is = is;
})(StructSpreadFieldNode || (StructSpreadFieldNode = {}));
export var DispatcherTypeNode;
(function (DispatcherTypeNode) {
    function destruct(node) {
        return {
            location: node.children.find(ResourceLocationNode.is),
            index: node.children.find(IndexBodyNode.is),
        };
    }
    DispatcherTypeNode.destruct = destruct;
    function is(node) {
        return (node?.type === 'mcdoc:type/dispatcher');
    }
    DispatcherTypeNode.is = is;
})(DispatcherTypeNode || (DispatcherTypeNode = {}));
export var UnionTypeNode;
(function (UnionTypeNode) {
    function destruct(node) {
        return { members: node.children.filter(TypeNode.is) };
    }
    UnionTypeNode.destruct = destruct;
    function is(node) {
        return node?.type === 'mcdoc:type/union';
    }
    UnionTypeNode.is = is;
})(UnionTypeNode || (UnionTypeNode = {}));
export var InjectionNode;
(function (InjectionNode) {
    function destruct(node) {
        return { injection: node.children.find(InjectionContentNode.is) };
    }
    InjectionNode.destruct = destruct;
    function is(node) {
        return node?.type === 'mcdoc:injection';
    }
    InjectionNode.is = is;
})(InjectionNode || (InjectionNode = {}));
export var InjectionContentNode;
(function (InjectionContentNode) {
    function is(node) {
        return EnumInjectionNode.is(node) || StructInjectionNode.is(node);
    }
    InjectionContentNode.is = is;
})(InjectionContentNode || (InjectionContentNode = {}));
export var EnumInjectionNode;
(function (EnumInjectionNode) {
    function is(node) {
        return (node?.type === 'mcdoc:injection/enum');
    }
    EnumInjectionNode.is = is;
})(EnumInjectionNode || (EnumInjectionNode = {}));
export var StructInjectionNode;
(function (StructInjectionNode) {
    function is(node) {
        return (node?.type === 'mcdoc:injection/struct');
    }
    StructInjectionNode.is = is;
})(StructInjectionNode || (StructInjectionNode = {}));
export var TypeAliasNode;
(function (TypeAliasNode) {
    function destruct(node) {
        return {
            attributes: node.children.filter(AttributeNode.is),
            docComments: node.children.find(DocCommentsNode.is),
            identifier: node.children.find(IdentifierNode.is),
            keyword: node.children.find(LiteralNode.is),
            typeParams: node.children.find(TypeParamBlockNode.is),
            rhs: node.children.find(TypeNode.is),
        };
    }
    TypeAliasNode.destruct = destruct;
    function is(node) {
        return node?.type === 'mcdoc:type_alias';
    }
    TypeAliasNode.is = is;
})(TypeAliasNode || (TypeAliasNode = {}));
export var UseStatementNode;
(function (UseStatementNode) {
    function destruct(node) {
        return {
            binding: node.children.find(IdentifierNode.is),
            path: node.children.find(PathNode.is),
        };
    }
    UseStatementNode.destruct = destruct;
    function is(node) {
        return (node?.type === 'mcdoc:use_statement');
    }
    UseStatementNode.is = is;
})(UseStatementNode || (UseStatementNode = {}));
//# sourceMappingURL=index.js.map