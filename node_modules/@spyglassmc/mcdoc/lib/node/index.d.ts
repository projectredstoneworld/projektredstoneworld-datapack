import type { AstNode, ColorTokenType, SymbolBaseNode } from '@spyglassmc/core';
import { CommentNode, FloatNode, IntegerNode, ResourceLocationNode, StringNode } from '@spyglassmc/core';
export interface ModuleNode extends AstNode {
    type: 'mcdoc:module';
    children: TopLevelNode[];
}
export declare namespace ModuleNode {
    function is(node: AstNode | undefined): node is ModuleNode;
}
export type TopLevelNode = CommentNode | DispatchStatementNode | EnumNode | InjectionNode | StructNode | TypeAliasNode | UseStatementNode;
export declare namespace TopLevelNode {
    function is(node: AstNode | undefined): node is TopLevelNode;
}
export interface DispatchStatementNode extends AstNode {
    type: 'mcdoc:dispatch_statement';
    children: (CommentNode | PrelimNode | LiteralNode | ResourceLocationNode | IndexBodyNode | TypeParamBlockNode | TypeNode)[];
}
export declare namespace DispatchStatementNode {
    function destruct(node: DispatchStatementNode): {
        attributes: AttributeNode[];
        location?: ResourceLocationNode;
        index?: IndexBodyNode;
        target?: TypeNode;
        typeParams?: TypeParamBlockNode;
    };
    function is(node: AstNode | undefined): node is DispatchStatementNode;
}
export interface LiteralNode extends AstNode {
    type: 'mcdoc:literal';
    value: string;
    colorTokenType?: ColorTokenType;
}
export declare namespace LiteralNode {
    function is(node: AstNode | undefined): node is LiteralNode;
}
export interface IndexBodyNode extends AstNode {
    type: 'mcdoc:index_body';
    children: (CommentNode | IndexNode)[];
}
export declare namespace IndexBodyNode {
    function destruct(node: IndexBodyNode): {
        parallelIndices: IndexNode[];
    };
    function is(node: AstNode | undefined): node is IndexBodyNode;
}
export type IndexNode = StaticIndexNode | DynamicIndexNode;
export declare namespace IndexNode {
    function is(node: AstNode | undefined): node is IndexNode;
}
export type StaticIndexNode = LiteralNode | IdentifierNode | StringNode | ResourceLocationNode;
export declare namespace StaticIndexNode {
    function is(node: AstNode | undefined): node is StaticIndexNode;
}
export interface IdentifierNode extends SymbolBaseNode {
    type: 'mcdoc:identifier';
}
export declare namespace IdentifierNode {
    function is(node: AstNode | undefined): node is IdentifierNode;
}
export interface DynamicIndexNode extends AstNode {
    type: 'mcdoc:dynamic_index';
    children: (CommentNode | AccessorKeyNode)[];
}
export declare namespace DynamicIndexNode {
    function destruct(node: DynamicIndexNode): {
        keys: AccessorKeyNode[];
    };
    function is(node: AstNode | undefined): node is DynamicIndexNode;
}
export type AccessorKeyNode = LiteralNode | IdentifierNode | StringNode;
export declare namespace AccessorKeyNode {
    function is(node: AstNode | undefined): node is AccessorKeyNode;
}
export type TypeNode = AnyTypeNode | BooleanTypeNode | StringTypeNode | LiteralTypeNode | NumericTypeNode | PrimitiveArrayTypeNode | ListTypeNode | TupleTypeNode | EnumNode | StructNode | ReferenceTypeNode | DispatcherTypeNode | UnionTypeNode;
export declare namespace TypeNode {
    function is(node: AstNode | undefined): node is TypeNode;
}
export interface TypeBaseNode<CN extends AstNode> extends AstNode {
    type: `mcdoc:${string}`;
    children: (CommentNode | AttributeNode | IndexBodyNode | TypeArgBlockNode | CN)[];
}
export declare namespace TypeBaseNode {
    function destruct(node: TypeBaseNode<any>): {
        appendixes: (IndexBodyNode | TypeArgBlockNode)[];
        attributes: AttributeNode[];
    };
}
export interface AttributeNode extends AstNode {
    type: 'mcdoc:attribute';
    children: (CommentNode | IdentifierNode | AttributeValueNode)[];
}
export declare namespace AttributeNode {
    function destruct(node: AttributeNode): {
        name: IdentifierNode;
        value: AttributeValueNode | undefined;
    };
    function is(node: AstNode | undefined): node is AttributeNode;
}
export type AttributeValueNode = TypeNode | AttributeTreeNode;
export declare namespace AttributeValueNode {
    function is(node: AstNode | undefined): node is AttributeValueNode;
}
export interface AttributeTreeNode extends AstNode {
    type: 'mcdoc:attribute/tree';
    children: (CommentNode | AttributeTreePosValuesNode | AttributeTreeNamedValuesNode)[];
    delim: '(' | '[' | '{';
}
export declare namespace AttributeTreeNode {
    function destruct(node: AttributeTreeNode): {
        positional?: AttributeTreePosValuesNode;
        named?: AttributeTreeNamedValuesNode;
    };
    function is(node: AstNode | undefined): node is AttributeTreeNode;
}
export interface AttributeTreePosValuesNode extends AstNode {
    type: 'mcdoc:attribute/tree/pos';
    children: (CommentNode | AttributeValueNode)[];
}
export declare namespace AttributeTreePosValuesNode {
    function destruct(node: AttributeTreePosValuesNode): {
        values: AttributeValueNode[];
    };
    function is(node: AstNode | undefined): node is AttributeTreePosValuesNode;
}
export interface AttributeTreeNamedValuesNode extends AstNode {
    type: 'mcdoc:attribute/tree/named';
    children: (CommentNode | IdentifierNode | StringNode | AttributeValueNode)[];
}
export declare namespace AttributeTreeNamedValuesNode {
    function destruct(node: AttributeTreeNamedValuesNode): {
        values: AttributeTreeNamedKeyValuePair[];
    };
    function is(node: AstNode | undefined): node is AttributeTreeNamedValuesNode;
}
export interface AttributeTreeNamedKeyValuePair {
    key: IdentifierNode | StringNode;
    value: AttributeValueNode;
}
export interface TypeArgBlockNode extends AstNode {
    type: 'mcdoc:type_arg_block';
    children: (CommentNode | TypeNode)[];
}
export declare namespace TypeArgBlockNode {
    function destruct(node: TypeArgBlockNode): {
        args: TypeNode[];
    };
    function is(node: AstNode | undefined): node is TypeArgBlockNode;
}
export interface AnyTypeNode extends TypeBaseNode<LiteralNode> {
    type: 'mcdoc:type/any';
}
export declare namespace AnyTypeNode {
    function is(node: AstNode | undefined): node is AnyTypeNode;
}
export interface BooleanTypeNode extends TypeBaseNode<LiteralNode> {
    type: 'mcdoc:type/boolean';
}
export declare namespace BooleanTypeNode {
    function is(node: AstNode | undefined): node is BooleanTypeNode;
}
export interface IntRangeNode extends AstNode {
    type: 'mcdoc:int_range';
    children: (IntegerNode | LiteralNode)[];
}
export declare namespace IntRangeNode {
    function destruct(node: IntRangeNode): {
        kind: RangeKind;
        min?: IntegerNode;
        max?: IntegerNode;
    };
    function is(node: AstNode | undefined): node is IntRangeNode;
}
export interface LiteralTypeNode extends TypeBaseNode<LiteralTypeValueNode> {
    type: 'mcdoc:type/literal';
}
export declare namespace LiteralTypeNode {
    function destruct(node: LiteralTypeNode): {
        value: LiteralTypeValueNode;
    };
    function is(node: AstNode | undefined): node is LiteralTypeNode;
}
export type LiteralTypeValueNode = LiteralNode | TypedNumberNode | StringNode;
export declare namespace LiteralTypeValueNode {
    function is(node: AstNode | undefined): node is LiteralTypeValueNode;
}
export interface TypedNumberNode extends AstNode {
    type: 'mcdoc:typed_number';
    children: (FloatNode | IntegerNode | LiteralNode)[];
}
export declare namespace TypedNumberNode {
    function destruct(node: TypedNumberNode): {
        value: FloatNode | IntegerNode;
        suffix?: LiteralNode;
    };
    function is(node: AstNode | undefined): node is TypedNumberNode;
}
export interface NumericTypeNode extends TypeBaseNode<LiteralNode | FloatRangeNode | IntRangeNode> {
    type: 'mcdoc:type/numeric_type';
}
export declare namespace NumericTypeNode {
    function destruct(node: NumericTypeNode): {
        numericKind: LiteralNode;
        valueRange?: FloatRangeNode | IntRangeNode;
    };
    function is(node: AstNode | undefined): node is NumericTypeNode;
}
export declare const RangeExclusiveChar = "<";
/**
 * A 2-bit binary number is used to represent the kind of range.
 * The first bit from the left represents the start, the second bit from the left represents the end.
 * The bit is turned on if the range is exclusive on that end.
 */
export type RangeKind = 0b00 | 0b01 | 0b10 | 0b11;
export declare namespace RangeKind {
    function isLeftExclusive(rangeKind: RangeKind): boolean;
    function isRightExclusive(rangeKind: RangeKind): boolean;
}
export declare function getRangeDelimiter(kind: RangeKind): string;
export interface FloatRangeNode extends AstNode {
    type: 'mcdoc:float_range';
    children: (FloatNode | LiteralNode)[];
}
export declare namespace FloatRangeNode {
    function destruct(node: FloatRangeNode): {
        kind: RangeKind;
        min?: FloatNode;
        max?: FloatNode;
    };
    function is(node: AstNode | undefined): node is FloatRangeNode;
}
export interface PrimitiveArrayTypeNode extends TypeBaseNode<LiteralNode | IntRangeNode> {
    type: 'mcdoc:type/primitive_array';
}
export declare namespace PrimitiveArrayTypeNode {
    function destruct(node: PrimitiveArrayTypeNode): {
        arrayKind: LiteralNode;
        lengthRange?: IntRangeNode;
        valueRange?: IntRangeNode;
    };
    function is(node: AstNode | undefined): node is PrimitiveArrayTypeNode;
}
export interface ListTypeNode extends TypeBaseNode<TypeNode | IntRangeNode> {
    type: 'mcdoc:type/list';
}
export declare namespace ListTypeNode {
    function destruct(node: ListTypeNode): {
        item: TypeNode;
        lengthRange?: IntRangeNode;
    };
    function is(node: AstNode | undefined): node is ListTypeNode;
}
export interface StringTypeNode extends TypeBaseNode<LiteralNode | IntRangeNode> {
    type: 'mcdoc:type/string';
}
export declare namespace StringTypeNode {
    function destruct(node: StringTypeNode): {
        lengthRange?: IntRangeNode;
    };
    function is(node: AstNode | undefined): node is StringTypeNode;
}
export interface TupleTypeNode extends TypeBaseNode<TypeNode> {
    type: 'mcdoc:type/tuple';
}
export declare namespace TupleTypeNode {
    function destruct(node: TupleTypeNode): {
        items: TypeNode[];
    };
    function is(node: AstNode | undefined): node is TupleTypeNode;
}
export interface EnumNode extends TypeBaseNode<DocCommentsNode | LiteralNode | IdentifierNode | EnumBlockNode> {
    type: 'mcdoc:enum';
}
export type EnumKind = typeof EnumNode.Kinds extends Set<infer V> ? V : never;
export declare namespace EnumNode {
    const Kinds: Set<"string" | "float" | "byte" | "short" | "int" | "long" | "double">;
    function destruct(node: EnumNode): {
        block: EnumBlockNode;
        docComments?: DocCommentsNode;
        enumKind?: EnumKind;
        identifier?: IdentifierNode;
        keyword: LiteralNode;
    };
    function is(node: AstNode | undefined): node is EnumNode;
}
export interface DocCommentsNode extends AstNode {
    type: 'mcdoc:doc_comments';
    children: CommentNode[];
}
export declare namespace DocCommentsNode {
    /**
     * @returns The text content of this doc comment block.
     *
     * If every line contains a leading space or is empty, stripe the leading spaces off.
     * Trailing whitespace characters at the end are removed.
     *
     * e.g., given
     * ```
     * /// This is an example doc comment.
     * ///
     * /// Another line.
     * ```
     *
     * "This is an example doc comment.\n\nAnother line." is returned.
     */
    function asText(node: DocCommentsNode | undefined): string | undefined;
    function is(node: AstNode | undefined): node is DocCommentsNode;
}
export interface EnumBlockNode extends AstNode {
    type: 'mcdoc:enum/block';
    children: (CommentNode | EnumFieldNode)[];
}
export declare namespace EnumBlockNode {
    function destruct(node: EnumBlockNode): {
        fields: EnumFieldNode[];
    };
    function is(node: AstNode | undefined): node is EnumBlockNode;
}
export interface EnumFieldNode extends AstNode {
    type: 'mcdoc:enum/field';
    children: (CommentNode | PrelimNode | IdentifierNode | EnumValueNode)[];
}
export declare namespace EnumFieldNode {
    function destruct(node: EnumFieldNode): {
        attributes: AttributeNode[];
        docComments?: DocCommentsNode;
        identifier: IdentifierNode;
        value: EnumValueNode;
    };
    function is(node: AstNode | undefined): node is EnumFieldNode;
}
export type EnumValueNode = TypedNumberNode | StringNode;
export declare namespace EnumValueNode {
    function is(node: AstNode | undefined): node is EnumValueNode;
}
export type PrelimNode = AttributeNode | DocCommentsNode;
export declare namespace PrelimNode {
    function is(node: AstNode | undefined): node is PrelimNode;
}
export interface StructNode extends TypeBaseNode<DocCommentsNode | LiteralNode | IdentifierNode | StructBlockNode> {
    type: 'mcdoc:struct';
}
export declare namespace StructNode {
    function destruct(node: StructNode): {
        block: StructBlockNode;
        docComments?: DocCommentsNode;
        identifier?: IdentifierNode;
        keyword: LiteralNode;
    };
    function is(node: AstNode | undefined): node is StructNode;
}
export interface ReferenceTypeNode extends TypeBaseNode<PathNode> {
    type: 'mcdoc:type/reference';
}
export declare namespace ReferenceTypeNode {
    function destruct(node: ReferenceTypeNode): {
        path: PathNode;
    };
    function is(node: AstNode | undefined): node is ReferenceTypeNode;
}
export interface TypeParamBlockNode extends AstNode {
    type: 'mcdoc:type_param_block';
    children: (CommentNode | TypeParamNode)[];
}
export declare namespace TypeParamBlockNode {
    function destruct(node: TypeParamBlockNode): {
        params: TypeParamNode[];
    };
    function is(node: AstNode | undefined): node is TypeParamBlockNode;
}
export interface TypeParamNode extends AstNode {
    type: 'mcdoc:type_param';
    children: (CommentNode | IdentifierNode | LiteralNode)[];
}
export declare namespace TypeParamNode {
    function destruct(node: TypeParamNode): {
        identifier: IdentifierNode;
    };
    function is(node: AstNode | undefined): node is TypeParamNode;
}
export interface PathNode extends AstNode {
    type: 'mcdoc:path';
    children: (LiteralNode | IdentifierNode)[];
    isAbsolute?: boolean;
}
export declare namespace PathNode {
    function destruct(node: PathNode | undefined): {
        children: (LiteralNode | IdentifierNode)[];
        isAbsolute?: boolean;
        lastIdentifier?: IdentifierNode;
    };
    function is(node: AstNode | undefined): node is PathNode;
}
export interface StructBlockNode extends AstNode {
    type: 'mcdoc:struct/block';
    children: (CommentNode | StructFieldNode)[];
}
export declare namespace StructBlockNode {
    function destruct(node: StructBlockNode): {
        fields: StructFieldNode[];
    };
    function is(node: AstNode | undefined): node is StructBlockNode;
}
export type StructFieldNode = StructPairFieldNode | StructSpreadFieldNode;
export declare namespace StructFieldNode {
    function is(node: AstNode | undefined): node is StructFieldNode;
}
export interface StructPairFieldNode extends AstNode {
    type: 'mcdoc:struct/field/pair';
    children: (CommentNode | PrelimNode | StructKeyNode | TypeNode)[];
    isOptional?: boolean;
}
export declare namespace StructPairFieldNode {
    function destruct(node: StructPairFieldNode): {
        attributes: AttributeNode[];
        docComments?: DocCommentsNode;
        key: StructKeyNode;
        type: TypeNode;
        isOptional?: boolean;
    };
    function is(node: AstNode | undefined): node is StructPairFieldNode;
}
export type StructKeyNode = StringNode | IdentifierNode | StructMapKeyNode;
export declare namespace StructKeyNode {
    function is(node: AstNode | undefined): node is StructKeyNode;
}
export interface StructMapKeyNode extends AstNode {
    type: 'mcdoc:struct/map_key';
    children: (CommentNode | TypeNode)[];
}
export declare namespace StructMapKeyNode {
    function destruct(node: StructMapKeyNode): {
        type: TypeNode;
    };
    function is(node: AstNode | undefined): node is StructMapKeyNode;
}
export interface StructSpreadFieldNode extends AstNode {
    type: 'mcdoc:struct/field/spread';
    children: (CommentNode | AttributeNode | TypeNode)[];
}
export declare namespace StructSpreadFieldNode {
    function destruct(node: StructSpreadFieldNode): {
        attributes: AttributeNode[];
        type: TypeNode;
    };
    function is(node: AstNode | undefined): node is StructSpreadFieldNode;
}
export interface DispatcherTypeNode extends TypeBaseNode<ResourceLocationNode | IndexBodyNode> {
    type: 'mcdoc:type/dispatcher';
}
export declare namespace DispatcherTypeNode {
    function destruct(node: DispatcherTypeNode): {
        location: ResourceLocationNode;
        index: IndexBodyNode;
    };
    function is(node: AstNode | undefined): node is DispatcherTypeNode;
}
export interface UnionTypeNode extends TypeBaseNode<TypeNode> {
    type: 'mcdoc:type/union';
}
export declare namespace UnionTypeNode {
    function destruct(node: UnionTypeNode): {
        members: TypeNode[];
    };
    function is(node: AstNode | undefined): node is UnionTypeNode;
}
export interface InjectionNode extends AstNode {
    type: 'mcdoc:injection';
    children: (CommentNode | LiteralNode | InjectionContentNode)[];
}
export declare namespace InjectionNode {
    function destruct(node: InjectionNode): {
        injection: InjectionContentNode;
    };
    function is(node: AstNode | undefined): node is InjectionNode;
}
export type InjectionContentNode = EnumInjectionNode | StructInjectionNode;
export declare namespace InjectionContentNode {
    function is(node: AstNode | undefined): node is InjectionContentNode;
}
export interface EnumInjectionNode extends AstNode {
    type: 'mcdoc:injection/enum';
    children: (CommentNode | LiteralNode | PathNode | EnumBlockNode)[];
}
export declare namespace EnumInjectionNode {
    function is(node: AstNode | undefined): node is EnumInjectionNode;
}
export interface StructInjectionNode extends AstNode {
    type: 'mcdoc:injection/struct';
    children: (CommentNode | LiteralNode | PathNode | StructBlockNode)[];
}
export declare namespace StructInjectionNode {
    function is(node: AstNode | undefined): node is StructInjectionNode;
}
export interface TypeAliasNode extends AstNode {
    type: 'mcdoc:type_alias';
    children: (CommentNode | PrelimNode | LiteralNode | IdentifierNode | TypeParamBlockNode | TypeNode)[];
}
export declare namespace TypeAliasNode {
    function destruct(node: TypeAliasNode): {
        attributes: AttributeNode[];
        docComments?: DocCommentsNode;
        identifier: IdentifierNode;
        keyword: LiteralNode;
        typeParams?: TypeParamBlockNode;
        rhs?: TypeNode;
    };
    function is(node: AstNode | undefined): node is TypeAliasNode;
}
export interface UseStatementNode extends AstNode {
    type: 'mcdoc:use_statement';
    children: (CommentNode | LiteralNode | PathNode | IdentifierNode)[];
}
export declare namespace UseStatementNode {
    function destruct(node: UseStatementNode): {
        binding?: IdentifierNode;
        path?: PathNode;
    };
    function is(node: AstNode | undefined): node is UseStatementNode;
}
//# sourceMappingURL=index.d.ts.map