import { Arrayable, Dev } from '@spyglassmc/core';
import { getRangeDelimiter, RangeKind } from '../node/index.js';
export var Attributes;
(function (Attributes) {
    function equals(a, b) {
        if (a?.length !== b?.length) {
            return false;
        }
        if (!a || !b) {
            return true;
        }
        for (let i = 0; i < a.length; i++) {
            if (!Attribute.equals(a[i], b[i])) {
                return false;
            }
        }
        return true;
    }
    Attributes.equals = equals;
})(Attributes || (Attributes = {}));
export var Attribute;
(function (Attribute) {
    function equals(a, b) {
        if (a.name !== b.name) {
            return false;
        }
        if (a.value && b.value) {
            return AttributeValue.equals(a.value, b.value);
        }
        return a.value === b.value;
    }
    Attribute.equals = equals;
})(Attribute || (Attribute = {}));
export var AttributeValue;
(function (AttributeValue) {
    function equals(a, b) {
        if (a.kind !== b.kind) {
            return false;
        }
        if (a.kind === 'tree') {
            if (Object.keys(a.values).length !== Object.keys(b.values).length) {
                return false;
            }
            for (const kvp of Object.entries(a.values)) {
                const other = b.values[kvp[0]];
                if (!other) {
                    return false;
                }
                if (!equals(kvp[1], other)) {
                    return false;
                }
            }
            return true;
        }
        else {
            return McdocType.equals(a, b);
        }
    }
    AttributeValue.equals = equals;
})(AttributeValue || (AttributeValue = {}));
export var NumericRange;
(function (NumericRange) {
    function isInRange(range, val) {
        const { min = -Infinity, max = Infinity } = range;
        if (RangeKind.isLeftExclusive(range.kind) ? val <= min : val < min) {
            return false;
        }
        if (RangeKind.isRightExclusive(range.kind) ? val >= max : val > max) {
            return false;
        }
        return true;
    }
    NumericRange.isInRange = isInRange;
    function equals(a, b) {
        return a.kind === b.kind
            && a.min === b.min
            && a.max === b.max;
    }
    NumericRange.equals = equals;
    function intersect(a, b) {
        const min = a.min !== undefined && b.min !== undefined
            ? Math.max(a.min, b.min)
            : a.min !== undefined
                ? a.min
                : b.min;
        const max = a.max !== undefined && b.max !== undefined
            ? Math.min(a.max, b.max)
            : a.max !== undefined
                ? a.max
                : b.max;
        let kind = 0b00;
        if (min === a.min && RangeKind.isLeftExclusive(a.kind)) {
            kind |= 0b10;
        }
        else if (min === b.min && RangeKind.isLeftExclusive(b.kind)) {
            kind |= 0b10;
        }
        if (max === a.max && RangeKind.isRightExclusive(a.kind)) {
            kind |= 0b01;
        }
        else if (max === b.max && RangeKind.isRightExclusive(b.kind)) {
            kind |= 0b01;
        }
        return { kind: kind, min, max };
    }
    NumericRange.intersect = intersect;
    function toString({ kind, min, max }) {
        return min === max && kind === 0b00
            ? min !== undefined ? `${min}` : getRangeDelimiter(kind)
            : `${min ?? ''}${getRangeDelimiter(kind)}${max ?? ''}`;
    }
    NumericRange.toString = toString;
})(NumericRange || (NumericRange = {}));
export const StaticIndexKeywords = Object.freeze(['fallback', 'none', 'unknown', 'spawnitem', 'blockitem']);
export var ParallelIndices;
(function (ParallelIndices) {
    function equals(a, b) {
        if (a.length !== b.length) {
            return false;
        }
        for (let i = 0; i < a.length; i++) {
            const first = a[i];
            const second = b[i];
            if (first.kind !== second.kind) {
                return false;
            }
            if (first.kind === 'static') {
                return first.value !== second.value;
            }
            if (first.accessor.length !== second.accessor.length) {
                return false;
            }
            for (let j = 0; j < first.accessor.length; j++) {
                const firstAcc = first.accessor[j];
                const secondAcc = second.accessor[j];
                if (typeof firstAcc === 'string' || typeof secondAcc === 'string') {
                    if (firstAcc !== secondAcc) {
                        return false;
                    }
                }
                else if (firstAcc.keyword !== secondAcc.keyword) {
                    return false;
                }
            }
        }
        return true;
    }
    ParallelIndices.equals = equals;
})(ParallelIndices || (ParallelIndices = {}));
export const EmptyUnion = Object.freeze({ kind: 'union', members: [] });
export function createEmptyUnion(attributes) {
    return {
        ...EmptyUnion,
        // attributes,
    };
}
export const NumericTypeIntKinds = Object.freeze(['byte', 'short', 'int', 'long']);
export const NumericTypeFloatKinds = Object.freeze(['float', 'double']);
export const NumericTypeKinds = Object.freeze([...NumericTypeIntKinds, ...NumericTypeFloatKinds]);
export const PrimitiveArrayValueKinds = Object.freeze(['byte', 'int', 'long']);
export const PrimitiveArrayKinds = Object.freeze(PrimitiveArrayValueKinds.map((kind) => `${kind}_array`));
export var McdocType;
(function (McdocType) {
    function equals(a, b) {
        if (a.kind !== b.kind) {
            return false;
        }
        if (!Attributes.equals(a.attributes, b.attributes)) {
            return false;
        }
        switch (a.kind) {
            case 'literal':
                return a.value.kind === b.value.kind
                    && a.value.value === b.value.value;
            case 'byte':
            case 'short':
            case 'int':
            case 'long':
            case 'float':
            case 'double':
                return a.valueRange === b.valueRange;
            case 'string':
                return a.lengthRange === b.lengthRange;
            case 'byte_array':
            case 'int_array':
            case 'long_array':
                return a.lengthRange === b.lengthRange
                    && a.valueRange === b.valueRange;
            case 'list':
                return a.lengthRange === b.lengthRange
                    && equals(a.item, b.item);
            case 'tuple':
                if (a.items.length !== b.items.length) {
                    return false;
                }
                for (let i = 0; i < a.items.length; i++) {
                    if (!equals(a.items[i], b.items[i])) {
                        return false;
                    }
                }
                return true;
            case 'struct':
                return a.fields.length === b.fields.length && !a.fields.some(f => {
                    if (f.kind === 'pair') {
                        return !b.fields.some(of => of.kind === 'pair'
                            && f.optional === of.optional
                            && f.deprecated === of.deprecated
                            && Attributes.equals(f.attributes, of.attributes)
                            && (typeof f.key === 'string' || typeof of.key === 'string'
                                ? f.key === of.key
                                : equals(f.key, of.key))
                            && equals(f.type, of.type));
                    }
                    return !b.fields.some(of => of.kind === 'spread'
                        && Attributes.equals(f.attributes, of.attributes)
                        && equals(f.type, of.type));
                });
            case 'union':
                if (a.members.length !== b.members.length) {
                    return false;
                }
                for (let i = 0; i < a.members.length; i++) {
                    if (!equals(a.members[i], b.members[i])) {
                        return false;
                    }
                }
                return true;
            case 'enum':
                if (a.enumKind !== b.enumKind
                    || a.values.length !== b.values.length) {
                    return false;
                }
                for (let i = 0; i < a.values.length; i++) {
                    const first = a.values[i];
                    const second = b.values[i];
                    if (first.identifier !== second.identifier || first.value !== second.value
                        || !Attributes.equals(first.attributes, second.attributes)) {
                        return false;
                    }
                }
                return true;
            case 'reference':
                return a.path === b.path;
            case 'template':
                if (a.typeParams.length !== b.typeParams.length) {
                    return false;
                }
                for (let i = 0; i < a.typeParams.length; i++) {
                    if (a.typeParams[i].path !== b.typeParams[i].path) {
                        return false;
                    }
                }
                return equals(a.child, b.child);
            case 'concrete':
                if (a.typeArgs.length !== b.typeArgs.length) {
                    return false;
                }
                for (let i = 0; i < a.typeArgs.length; i++) {
                    if (!equals(a.typeArgs[i], b.typeArgs[i])) {
                        return false;
                    }
                }
                return equals(a.child, b.child);
            case 'indexed':
                if (ParallelIndices.equals(a.parallelIndices, b.parallelIndices)) {
                    return false;
                }
                return equals(a.child, b.child);
            case 'dispatcher':
                if (a.registry !== b.registry) {
                    return false;
                }
                return ParallelIndices.equals(a.parallelIndices, b.parallelIndices);
            case 'mapped':
                if (Object.keys(a.mapping).length !== Object.keys(b.mapping).length) {
                    return false;
                }
                for (const kvp of Object.entries(a.mapping)) {
                    const other = b.mapping[kvp[0]];
                    if (!other) {
                        return false;
                    }
                    if (!equals(kvp[1], other)) {
                        return false;
                    }
                }
                return equals(a.child, b.child);
            default:
                return true;
        }
    }
    McdocType.equals = equals;
    function toString(type) {
        const rangeToString = (range) => {
            return range ? ` @ ${NumericRange.toString(range)}` : '';
        };
        const indicesToString = (indices) => {
            const strings = [];
            for (const index of Arrayable.toArray(indices)) {
                if (index === undefined) {
                    strings.push('()');
                }
                else {
                    strings.push(index.kind === 'static'
                        ? `[${index.value}]`
                        : `[[${index.accessor.map((v) => (typeof v === 'string' ? v : v.keyword)).join('.')}]]`);
                }
            }
            return `[${strings.join(', ')}]`;
        };
        if (type === undefined) {
            return '<unknown>';
        }
        let attributesString = '';
        if (type.attributes?.length) {
            for (const attribute of type.attributes) {
                attributesString += `#[${attribute.name}${attribute.value ? '=<value ...>' : ''}] `;
            }
        }
        let typeString;
        switch (type.kind) {
            case 'any':
            case 'boolean':
                typeString = type.kind;
                break;
            case 'byte':
                typeString = `byte${rangeToString(type.valueRange)}`;
                break;
            case 'byte_array':
                typeString = `byte${rangeToString(type.valueRange)}[]${rangeToString(type.lengthRange)}`;
                break;
            case 'concrete':
                typeString = `${toString(type.child)}${type.typeArgs.length ? `<${type.typeArgs.map(toString).join(', ')}>` : ''}`;
                break;
            case 'dispatcher':
                typeString = `${type.registry ?? 'spyglass:unknown'}[${indicesToString(type.parallelIndices)}]`;
                break;
            case 'double':
                typeString = `double${rangeToString(type.valueRange)}`;
                break;
            case 'enum':
                typeString = '<enum ...>';
                break;
            case 'float':
                typeString = `float${rangeToString(type.valueRange)}`;
                break;
            case 'indexed':
                typeString = `${toString(type.child)}${indicesToString(type.parallelIndices)}`;
                break;
            case 'int':
                typeString = `int${rangeToString(type.valueRange)}`;
                break;
            case 'int_array':
                typeString = `int${rangeToString(type.valueRange)}[]${rangeToString(type.lengthRange)}`;
                break;
            case 'list':
                typeString = `[${toString(type.item)}]${rangeToString(type.lengthRange)}`;
                break;
            case 'literal':
                typeString = `${type.value.value}`;
                break;
            case 'long':
                typeString = `long${rangeToString(type.valueRange)}`;
                break;
            case 'long_array':
                typeString = `long${rangeToString(type.valueRange)}[]${rangeToString(type.lengthRange)}`;
                break;
            case 'mapped':
                typeString = toString(type.child);
                break;
            case 'reference':
                typeString = type.path ?? '<unknown_reference>';
                break;
            case 'short':
                typeString = `short${rangeToString(type.valueRange)}`;
                break;
            case 'string':
                typeString = `string${rangeToString(type.lengthRange)}`;
                break;
            case 'struct':
                typeString = '<struct ...>';
                break;
            case 'template':
                typeString = `${toString(type.child)}${type.typeParams.length
                    ? `<${type.typeParams.map((v) => `?${v.path}`).join(', ')}>`
                    : ''}`;
                break;
            case 'tuple':
                typeString = `[${type.items.map((v) => toString(v)).join(',')}${type.items.length === 1 ? ',' : ''}]`;
                break;
            case 'union':
                typeString = `(${type.members.map(toString).join(' | ')})`;
                break;
            case 'unsafe':
                typeString = 'unsafe';
                break;
            default:
                Dev.assertNever(type);
        }
        return attributesString + typeString;
    }
    McdocType.toString = toString;
})(McdocType || (McdocType = {}));
//# sourceMappingURL=index.js.map