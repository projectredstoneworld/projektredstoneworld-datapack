import * as core from '@spyglassmc/core';
import { ReleaseVersion } from '../../dependency/common.js';
export var BlockStatesNode;
(function (BlockStatesNode) {
    /* istanbul ignore next */
    function is(node) {
        return node.type === 'mcfunction:block/states';
    }
    BlockStatesNode.is = is;
})(BlockStatesNode || (BlockStatesNode = {}));
export var BlockNode;
(function (BlockNode) {
    function is(node) {
        return node?.type === 'mcfunction:block';
    }
    BlockNode.is = is;
    function mock(range, isPredicate) {
        const id = core.ResourceLocationNode.mock(range, { category: 'block', allowTag: isPredicate });
        return {
            type: 'mcfunction:block',
            range: core.Range.get(range),
            children: [id],
            id,
            isPredicate: false,
        };
    }
    BlockNode.mock = mock;
})(BlockNode || (BlockNode = {}));
export const CoordinateNotations = ['', '~', '^'];
export var CoordinateNode;
(function (CoordinateNode) {
    function mock(range) {
        return { type: 'mcfunction:coordinate', range: core.Range.get(range), notation: '', value: 0 };
    }
    CoordinateNode.mock = mock;
    /**
     * @returns A number in the range `[-180.0, 180.0)`.
     */
    function toDegree(node) {
        // TODO: For relative coordinates, const value = (node.value + baseCoordinate) % 360
        const value = node.value % 360;
        return value >= 180 ? value - 360 : value < -180 ? value + 360 : value;
    }
    CoordinateNode.toDegree = toDegree;
})(CoordinateNode || (CoordinateNode = {}));
export var EntitySelectorArgumentsNode;
(function (EntitySelectorArgumentsNode) {
    /* istanbul ignore next */
    function is(node) {
        return (node.type === 'mcfunction:entity_selector/arguments');
    }
    EntitySelectorArgumentsNode.is = is;
})(EntitySelectorArgumentsNode || (EntitySelectorArgumentsNode = {}));
const EntitySelectorVariables = ['a', 'e', 'p', 'r', 's', 'n'];
export var EntitySelectorVariable;
(function (EntitySelectorVariable) {
    /* istanbul ignore next */
    function is(value) {
        return EntitySelectorVariables.includes(value);
    }
    EntitySelectorVariable.is = is;
})(EntitySelectorVariable || (EntitySelectorVariable = {}));
const EntitySelectorAtVariables = EntitySelectorVariables.map((v) => `@${v}`);
export var EntitySelectorAtVariable;
(function (EntitySelectorAtVariable) {
    /* istanbul ignore next */
    function is(value) {
        return EntitySelectorAtVariables.includes(value);
    }
    EntitySelectorAtVariable.is = is;
    /**
     * Should be used to get a list of available selectors for the current version.
     */
    function filterAvailable(ctx) {
        const release = ctx.project['loadedVersion'];
        return EntitySelectorAtVariables.filter(variable => !(variable === '@n' && release && ReleaseVersion.cmp(release, '1.21') < 0));
    }
    EntitySelectorAtVariable.filterAvailable = filterAvailable;
})(EntitySelectorAtVariable || (EntitySelectorAtVariable = {}));
export var EntitySelectorNode;
(function (EntitySelectorNode) {
    /* istanbul ignore next */
    function is(node) {
        return (node?.type === 'mcfunction:entity_selector');
    }
    EntitySelectorNode.is = is;
    function mock(range, options) {
        const literal = core.LiteralNode.mock(range, options);
        return {
            type: 'mcfunction:entity_selector',
            range: core.Range.get(range),
            children: [literal],
            variable: 'e',
        };
    }
    EntitySelectorNode.mock = mock;
    EntitySelectorNode.ArgumentKeys = new Set([
        'advancements',
        'distance',
        'gamemode',
        'level',
        'limit',
        'name',
        'nbt',
        'predicate',
        'scores',
        'sort',
        'tag',
        'team',
        'type',
        'x',
        'y',
        'z',
        'dx',
        'dy',
        'dz',
        'x_rotation',
        'y_rotation',
    ]);
    function canKeyExist(selector, argument, key) {
        const hasKey = (key) => !!argument.children.find((p) => p.key?.value === key);
        const hasNonInvertedKey = (key) => !!argument.children.find((p) => p.key?.value === key
            && !p.value?.inverted);
        switch (key) {
            case 'advancements':
            case 'distance':
            case 'level':
            case 'scores':
            case 'x':
            case 'y':
            case 'z':
            case 'dx':
            case 'dy':
            case 'dz':
            case 'x_rotation':
            case 'y_rotation':
                return hasKey(key) ? 1 /* Result.Duplicated */ : 0 /* Result.Ok */;
            case 'gamemode':
            case 'name':
            case 'team':
                return hasNonInvertedKey(key) ? 1 /* Result.Duplicated */ : 0 /* Result.Ok */;
            case 'limit':
            case 'sort':
                return selector.currentEntity
                    ? 2 /* Result.NotApplicable */
                    : hasKey(key)
                        ? 1 /* Result.Duplicated */
                        : 0 /* Result.Ok */;
            case 'type':
                return selector.typeLimited
                    ? hasKey(key) ? 1 /* Result.Duplicated */ : 2 /* Result.NotApplicable */
                    : 0 /* Result.Ok */;
        }
        return 0 /* Result.Ok */;
    }
    EntitySelectorNode.canKeyExist = canKeyExist;
})(EntitySelectorNode || (EntitySelectorNode = {}));
export var EntityNode;
(function (EntityNode) {
    function is(node) {
        return node?.type === 'mcfunction:entity';
    }
    EntityNode.is = is;
})(EntityNode || (EntityNode = {}));
export var ItemStackNode;
(function (ItemStackNode) {
    function is(node) {
        return node?.type === 'mcfunction:item_stack';
    }
    ItemStackNode.is = is;
    function mock(range) {
        const id = core.ResourceLocationNode.mock(range, { category: 'item' });
        return { type: 'mcfunction:item_stack', range: core.Range.get(range), children: [id], id };
    }
    ItemStackNode.mock = mock;
})(ItemStackNode || (ItemStackNode = {}));
export var ComponentListNode;
(function (ComponentListNode) {
    function is(node) {
        return node.type === 'mcfunction:component_list';
    }
    ComponentListNode.is = is;
})(ComponentListNode || (ComponentListNode = {}));
export var ComponentNode;
(function (ComponentNode) {
    function is(node) {
        return node.type === 'mcfunction:component';
    }
    ComponentNode.is = is;
})(ComponentNode || (ComponentNode = {}));
export var ComponentRemovalNode;
(function (ComponentRemovalNode) {
    function is(node) {
        return node.type === 'mcfunction:component_removal';
    }
    ComponentRemovalNode.is = is;
})(ComponentRemovalNode || (ComponentRemovalNode = {}));
export var ItemPredicateNode;
(function (ItemPredicateNode) {
    function is(node) {
        return node?.type === 'mcfunction:item_predicate';
    }
    ItemPredicateNode.is = is;
    function mock(range) {
        const id = core.ResourceLocationNode.mock(range, { category: 'item', allowTag: true });
        return { type: 'mcfunction:item_predicate', range: core.Range.get(range), children: [id], id };
    }
    ItemPredicateNode.mock = mock;
})(ItemPredicateNode || (ItemPredicateNode = {}));
export var ComponentTestsNode;
(function (ComponentTestsNode) {
    function is(node) {
        return node.type === 'mcfunction:component_tests';
    }
    ComponentTestsNode.is = is;
})(ComponentTestsNode || (ComponentTestsNode = {}));
export var ComponentTestsAnyOfNode;
(function (ComponentTestsAnyOfNode) {
    function is(node) {
        return node.type === 'mcfunction:component_tests_any_of';
    }
    ComponentTestsAnyOfNode.is = is;
})(ComponentTestsAnyOfNode || (ComponentTestsAnyOfNode = {}));
export var ComponentTestsAllOfNode;
(function (ComponentTestsAllOfNode) {
    function is(node) {
        return node.type === 'mcfunction:component_tests_all_of';
    }
    ComponentTestsAllOfNode.is = is;
})(ComponentTestsAllOfNode || (ComponentTestsAllOfNode = {}));
export var ComponentTestExactNode;
(function (ComponentTestExactNode) {
    function is(node) {
        return node.type === 'mcfunction:component_test_exact';
    }
    ComponentTestExactNode.is = is;
})(ComponentTestExactNode || (ComponentTestExactNode = {}));
export var ComponentTestExistsNode;
(function (ComponentTestExistsNode) {
    function is(node) {
        return node.type === 'mcfunction:component_test_exists';
    }
    ComponentTestExistsNode.is = is;
})(ComponentTestExistsNode || (ComponentTestExistsNode = {}));
export var ComponentTestSubpredicateNode;
(function (ComponentTestSubpredicateNode) {
    function is(node) {
        return node.type
            === 'mcfunction:component_test_sub_predicate';
    }
    ComponentTestSubpredicateNode.is = is;
})(ComponentTestSubpredicateNode || (ComponentTestSubpredicateNode = {}));
export var IntRangeNode;
(function (IntRangeNode) {
    function mock(range) {
        return {
            type: 'mcfunction:int_range',
            range: core.Range.get(range),
            children: [],
            value: [undefined, undefined],
        };
    }
    IntRangeNode.mock = mock;
})(IntRangeNode || (IntRangeNode = {}));
export var NbtNode;
(function (NbtNode) {
    /* istanbul ignore next */
    function is(node) {
        return node.type === 'mcfunction:nbt';
    }
    NbtNode.is = is;
})(NbtNode || (NbtNode = {}));
export var NbtPathNode;
(function (NbtPathNode) {
    /* istanbul ignore next */
    function is(node) {
        return node.type === 'mcfunction:nbt_path';
    }
    NbtPathNode.is = is;
})(NbtPathNode || (NbtPathNode = {}));
export var NbtResourceNode;
(function (NbtResourceNode) {
    /* istanbul ignore next */
    function is(node) {
        return node.type === 'mcfunction:nbt_resource';
    }
    NbtResourceNode.is = is;
})(NbtResourceNode || (NbtResourceNode = {}));
export var ObjectiveCriteriaNode;
(function (ObjectiveCriteriaNode) {
    ObjectiveCriteriaNode.SimpleValues = [
        'air',
        'armor',
        'deathCount',
        'dummy',
        'food',
        'health',
        'level',
        'playerKillCount',
        'totalKillCount',
        'trigger',
        'xp',
        ...core.Color.ColorNames.map((n) => `killedByTeam.${n}`),
        ...core.Color.ColorNames.map((n) => `teamkill.${n}`),
    ];
    ObjectiveCriteriaNode.ComplexCategories = new Map([
        ['broken', 'item'],
        ['crafted', 'item'],
        ['custom', 'custom_stat'],
        ['dropped', 'item'],
        ['killed', 'entity_type'],
        ['killed_by', 'entity_type'],
        ['mined', 'block'],
        ['picked_up', 'item'],
        ['used', 'item'],
    ]);
    ObjectiveCriteriaNode.ComplexSep = ':';
    function mock(range) {
        return { type: 'mcfunction:objective_criteria', range: core.Range.get(range) };
    }
    ObjectiveCriteriaNode.mock = mock;
})(ObjectiveCriteriaNode || (ObjectiveCriteriaNode = {}));
export var ParticleNode;
(function (ParticleNode) {
    // until 1.20.5
    const SpecialTypes = new Set([
        'block',
        'block_marker',
        'dust',
        'dust_color_transition',
        'falling_dust',
        'item',
        'sculk_charge',
        'shriek',
        'vibration',
    ]);
    function isSpecialType(type) {
        return SpecialTypes.has(type);
    }
    ParticleNode.isSpecialType = isSpecialType;
    // since 1.20.5
    const OptionTypes = new Set([
        ...SpecialTypes,
        'block_crumble',
        'dust_pillar',
        'entity_effect',
        'trail',
    ]);
    function requiresOptions(type, release) {
        if (type === 'flash' && ReleaseVersion.cmp(release, '1.21.9') >= 0) {
            return true;
        }
        return OptionTypes.has(type);
    }
    ParticleNode.requiresOptions = requiresOptions;
    function is(node) {
        return node?.type === 'mcfunction:particle';
    }
    ParticleNode.is = is;
    function mock(range) {
        const id = core.ResourceLocationNode.mock(range, { category: 'particle_type' });
        return { type: 'mcfunction:particle', range: core.Range.get(range), children: [id], id };
    }
    ParticleNode.mock = mock;
})(ParticleNode || (ParticleNode = {}));
export var ScoreHolderNode;
(function (ScoreHolderNode) {
    function mock(range) {
        const fakeName = core.SymbolNode.mock(range, { category: 'score_holder' });
        return {
            type: 'mcfunction:score_holder',
            range: core.Range.get(range),
            children: [fakeName],
            fakeName,
        };
    }
    ScoreHolderNode.mock = mock;
})(ScoreHolderNode || (ScoreHolderNode = {}));
export var TimeNode;
(function (TimeNode) {
    TimeNode.UnitToTicks = new Map([['', 1], ['t', 1], ['s', 20], ['d', 24000]]);
    TimeNode.Units = [...TimeNode.UnitToTicks.keys()];
})(TimeNode || (TimeNode = {}));
export var VectorNode;
(function (VectorNode) {
    function mock(range, options) {
        return {
            type: 'mcfunction:vector',
            range: core.Range.get(range),
            children: [],
            options,
            system: 0 /* CoordinateSystem.World */,
        };
    }
    VectorNode.mock = mock;
})(VectorNode || (VectorNode = {}));
//# sourceMappingURL=argument.js.map