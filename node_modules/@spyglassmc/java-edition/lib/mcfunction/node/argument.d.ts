import * as core from '@spyglassmc/core';
import type * as nbt from '@spyglassmc/nbt';
import { ReleaseVersion } from '../../dependency/common.js';
import type { NbtParserProperties } from '../tree/argument.js';
export interface BlockStatesNode extends core.RecordBaseNode<core.StringNode, core.StringNode> {
    type: 'mcfunction:block/states';
}
export declare namespace BlockStatesNode {
    function is(node: core.AstNode): node is BlockStatesNode;
}
export interface BlockNode extends core.AstNode {
    type: 'mcfunction:block';
    children: (core.ResourceLocationNode | BlockStatesNode | nbt.NbtCompoundNode)[];
    id: core.ResourceLocationNode;
    states?: BlockStatesNode;
    nbt?: nbt.NbtCompoundNode;
    isPredicate: boolean;
}
export declare namespace BlockNode {
    function is(node: core.DeepReadonly<core.AstNode> | undefined): node is BlockNode;
    function mock(range: core.RangeLike, isPredicate: boolean): BlockNode;
}
export declare const CoordinateNotations: readonly ["", "~", "^"];
export type CoordinateNodeNotation = typeof CoordinateNotations[number];
export interface CoordinateNode extends core.FloatBaseNode {
    type: 'mcfunction:coordinate';
    notation: CoordinateNodeNotation;
}
export declare namespace CoordinateNode {
    function mock(range: core.RangeLike): CoordinateNode;
    /**
     * @returns A number in the range `[-180.0, 180.0)`.
     */
    function toDegree(node: CoordinateNode): number;
}
export declare const enum CoordinateSystem {
    World = 0,
    Local = 1
}
export interface EntitySelectorAdvancementsArgumentCriteriaNode extends core.RecordBaseNode<core.StringNode | core.SymbolNode, core.BooleanNode> {
    type: 'mcfunction:entity_selector/arguments/advancements/criteria';
}
export interface EntitySelectorAdvancementsArgumentNode extends core.RecordBaseNode<core.ResourceLocationNode, core.BooleanNode | EntitySelectorAdvancementsArgumentCriteriaNode> {
    type: 'mcfunction:entity_selector/arguments/advancements';
}
export interface EntitySelectorScoresArgumentNode extends core.RecordBaseNode<core.SymbolNode, IntRangeNode> {
    type: 'mcfunction:entity_selector/arguments/scores';
}
export interface EntitySelectorInvertableArgumentValueNode<T extends core.AstNode> extends core.SequenceNode<core.LiteralNode | T> {
    type: 'mcfunction:entity_selector/arguments/value/invertable';
    value: T;
    inverted: boolean;
}
export interface EntitySelectorArgumentsNode extends core.RecordBaseNode<core.StringNode, any> {
    type: 'mcfunction:entity_selector/arguments';
}
export declare namespace EntitySelectorArgumentsNode {
    function is(node: core.AstNode): node is EntitySelectorArgumentsNode;
}
declare const EntitySelectorVariables: readonly ["a", "e", "p", "r", "s", "n"];
export type EntitySelectorVariable = typeof EntitySelectorVariables[number];
export declare namespace EntitySelectorVariable {
    function is(value: string): value is EntitySelectorVariable;
}
declare const EntitySelectorAtVariables: ("@s" | "@a" | "@e" | "@p" | "@r" | "@n")[];
export type EntitySelectorAtVariable = typeof EntitySelectorAtVariables[number];
export declare namespace EntitySelectorAtVariable {
    function is(value: string): value is EntitySelectorAtVariable;
    /**
     * Should be used to get a list of available selectors for the current version.
     */
    function filterAvailable(ctx: core.ContextBase): ("@s" | "@a" | "@e" | "@p" | "@r" | "@n")[];
}
export interface EntitySelectorNode extends core.AstNode {
    type: 'mcfunction:entity_selector';
    children: [core.LiteralNode, ...([] | [EntitySelectorArgumentsNode])];
    variable: EntitySelectorVariable;
    arguments?: EntitySelectorArgumentsNode;
    currentEntity?: boolean;
    dimensionLimited?: boolean;
    playersOnly?: boolean;
    predicates?: string[];
    chunkLimited?: boolean;
    single?: boolean;
    typeLimited?: boolean;
}
export declare namespace EntitySelectorNode {
    function is<T extends core.DeepReadonly<core.AstNode> | undefined>(node: T): node is core.InheritReadonly<EntitySelectorNode, T>;
    function mock(range: core.RangeLike, options: core.LiteralOptions): EntitySelectorNode;
    const ArgumentKeys: Set<"tag" | "team" | "predicate" | "type" | "level" | "name" | "sort" | "advancements" | "nbt" | "distance" | "gamemode" | "limit" | "scores" | "x" | "y" | "z" | "dx" | "dy" | "dz" | "x_rotation" | "y_rotation">;
    type ArgumentKey = typeof ArgumentKeys extends Set<infer T> ? T : undefined;
    const enum Result {
        Ok = 0,
        Duplicated = 1,
        NotApplicable = 2
    }
    function canKeyExist(selector: core.DeepReadonly<EntitySelectorNode>, argument: core.DeepReadonly<EntitySelectorArgumentsNode>, key: string): Result;
}
export interface EntityNode extends core.AstNode {
    type: 'mcfunction:entity';
    children: [core.StringNode | EntitySelectorNode | UuidNode];
    playerName?: core.StringNode;
    selector?: EntitySelectorNode;
    uuid?: UuidNode;
}
export declare namespace EntityNode {
    function is(node: core.AstNode | undefined): node is EntityNode;
}
export interface FloatRangeNode extends core.AstNode {
    type: 'mcfunction:float_range';
    children: (core.FloatNode | core.LiteralNode)[];
    value: [number | undefined, number | undefined];
}
export interface ItemStackNode extends core.AstNode {
    type: 'mcfunction:item_stack';
    children: (core.ResourceLocationNode | ComponentListNode | nbt.NbtCompoundNode)[];
    id: core.ResourceLocationNode;
    components?: ComponentListNode;
    nbt?: nbt.NbtCompoundNode;
}
export declare namespace ItemStackNode {
    function is(node: core.AstNode | undefined): node is ItemStackNode;
    function mock(range: core.RangeLike): ItemStackNode;
}
export interface ComponentListNode extends core.AstNode {
    type: 'mcfunction:component_list';
    children: (ComponentNode | ComponentRemovalNode)[];
    innerRange?: core.Range;
}
export declare namespace ComponentListNode {
    function is(node: core.AstNode): node is ComponentListNode;
}
export interface ComponentNode extends core.AstNode {
    type: 'mcfunction:component';
    children: (core.ResourceLocationNode | nbt.NbtNode)[];
    key: core.ResourceLocationNode;
    value?: nbt.NbtNode;
}
export declare namespace ComponentNode {
    function is(node: core.AstNode): node is ComponentNode;
}
export interface ComponentRemovalNode extends core.AstNode {
    type: 'mcfunction:component_removal';
    children: (core.LiteralNode | core.ResourceLocationNode)[];
    prefix: core.LiteralNode;
    key: core.ResourceLocationNode;
}
export declare namespace ComponentRemovalNode {
    function is(node: core.AstNode): node is ComponentRemovalNode;
}
export interface ItemPredicateNode extends core.AstNode {
    type: 'mcfunction:item_predicate';
    children: (core.ResourceLocationNode | core.LiteralNode | ComponentTestsNode | nbt.NbtCompoundNode)[];
    id: core.ResourceLocationNode | core.LiteralNode;
    tests?: ComponentTestsNode;
    nbt?: nbt.NbtCompoundNode;
}
export declare namespace ItemPredicateNode {
    function is(node: core.AstNode | undefined): node is ItemPredicateNode;
    function mock(range: core.RangeLike): ItemPredicateNode;
}
export interface ComponentTestsNode extends core.AstNode {
    type: 'mcfunction:component_tests';
    children?: [ComponentTestsAnyOfNode];
}
export declare namespace ComponentTestsNode {
    function is(node: core.AstNode): node is ComponentTestsNode;
}
export interface ComponentTestsAnyOfNode extends core.AstNode {
    type: 'mcfunction:component_tests_any_of';
    children: ComponentTestsAllOfNode[];
}
export declare namespace ComponentTestsAnyOfNode {
    function is(node: core.AstNode): node is ComponentTestsAnyOfNode;
}
export interface ComponentTestsAllOfNode extends core.AstNode {
    type: 'mcfunction:component_tests_all_of';
    children: ComponentTestNode[];
}
export declare namespace ComponentTestsAllOfNode {
    function is(node: core.AstNode): node is ComponentTestsAllOfNode;
}
export type ComponentTestNode = ComponentTestExactNode | ComponentTestExistsNode | ComponentTestSubpredicateNode;
export interface ComponentTestBaseNode extends core.AstNode {
    negated: boolean;
}
export interface ComponentTestExactNode extends ComponentTestBaseNode {
    type: 'mcfunction:component_test_exact';
    children: (core.ResourceLocationNode | nbt.NbtNode)[];
    key: core.ResourceLocationNode;
    value?: nbt.NbtNode;
}
export declare namespace ComponentTestExactNode {
    function is(node: core.AstNode): node is ComponentTestExactNode;
}
export interface ComponentTestExistsNode extends ComponentTestBaseNode {
    type: 'mcfunction:component_test_exists';
    children: [core.ResourceLocationNode];
    key: core.ResourceLocationNode;
}
export declare namespace ComponentTestExistsNode {
    function is(node: core.AstNode): node is ComponentTestExistsNode;
}
export interface ComponentTestSubpredicateNode extends ComponentTestBaseNode {
    type: 'mcfunction:component_test_sub_predicate';
    children: (core.ResourceLocationNode | nbt.NbtNode)[];
    key: core.ResourceLocationNode;
    value?: nbt.NbtNode;
}
export declare namespace ComponentTestSubpredicateNode {
    function is(node: core.AstNode): node is ComponentTestSubpredicateNode;
}
export interface IntRangeNode extends core.AstNode {
    type: 'mcfunction:int_range';
    children: (core.IntegerNode | core.LiteralNode)[];
    value: [number | undefined, number | undefined];
}
export declare namespace IntRangeNode {
    function mock(range: core.RangeLike): IntRangeNode;
}
export interface MessageNode extends core.AstNode {
    type: 'mcfunction:message';
    children: (core.StringNode | EntitySelectorNode)[];
}
export interface NbtNode extends core.AstNode {
    type: 'mcfunction:nbt';
    children: [nbt.NbtNode];
    properties?: NbtParserProperties;
}
export declare namespace NbtNode {
    function is(node: core.AstNode): node is NbtNode;
}
export interface NbtPathNode extends core.AstNode {
    type: 'mcfunction:nbt_path';
    children: [nbt.NbtPathNode];
    properties?: NbtParserProperties;
}
export declare namespace NbtPathNode {
    function is(node: core.AstNode): node is NbtPathNode;
}
export interface NbtResourceNode extends core.AstNode {
    type: 'mcfunction:nbt_resource';
    children: [nbt.NbtNode];
    category: string;
}
export declare namespace NbtResourceNode {
    function is(node: core.AstNode): node is NbtResourceNode;
}
export interface ObjectiveCriteriaNode extends core.AstNode {
    type: 'mcfunction:objective_criteria';
    children?: [core.ResourceLocationNode, core.ResourceLocationNode];
    simpleValue?: string;
}
export declare namespace ObjectiveCriteriaNode {
    const SimpleValues: string[];
    const ComplexCategories: Map<string, "block" | "fluid" | "instrument" | "activity" | "armor_material" | "attribute" | "attribute_type" | "block_entity_type" | "block_predicate_type" | "block_type" | "chunk_status" | "command_argument_type" | "consume_effect_type" | "creative_mode_tab" | "custom_stat" | "data_component_predicate_type" | "data_component_type" | "debug_subscription" | "decorated_pot_pattern" | "decorated_pot_patterns" | "dialog_action_type" | "dialog_body_type" | "dialog_type" | "enchantment_effect_component_type" | "enchantment_entity_effect_type" | "enchantment_level_based_value_type" | "enchantment_location_based_effect_type" | "enchantment_provider_type" | "enchantment_value_effect_type" | "entity_sub_predicate_type" | "entity_type" | "environment_attribute" | "float_provider_type" | "game_event" | "game_rule" | "height_provider_type" | "incoming_rpc_methods" | "input_control_type" | "int_provider_type" | "item" | "item_sub_predicate_type" | "loot_condition_type" | "loot_function_type" | "loot_nbt_provider_type" | "loot_number_provider_type" | "loot_pool_entry_type" | "loot_score_provider_type" | "map_decoration_type" | "memory_module_type" | "menu" | "mob_effect" | "motive" | "number_format_type" | "outgoing_rpc_methods" | "particle_type" | "permission_check_type" | "permission_type" | "point_of_interest_type" | "pos_rule_test" | "position_source_type" | "potion" | "recipe_book_category" | "recipe_display" | "recipe_serializer" | "recipe_type" | "rule_block_entity_modifier" | "rule_test" | "schedule" | "sensor_type" | "slot_display" | "slot_source_type" | "sound_event" | "spawn_condition_type" | "stat_type" | "test_environment_definition_type" | "test_function" | "test_instance_type" | "trigger_type" | "ticket_type" | "villager_profession" | "villager_type" | "worldgen/biome_source" | "worldgen/block_placer_type" | "worldgen/block_state_provider_type" | "worldgen/carver" | "worldgen/chunk_generator" | "worldgen/decorator" | "worldgen/density_function_type" | "worldgen/feature" | "worldgen/feature_size_type" | "worldgen/foliage_placer_type" | "worldgen/material_condition" | "worldgen/material_rule" | "worldgen/placement_modifier_type" | "worldgen/pool_alias_binding" | "worldgen/root_placer_type" | "worldgen/structure_feature" | "worldgen/structure_piece" | "worldgen/structure_placement" | "worldgen/structure_pool_element" | "worldgen/structure_processor" | "worldgen/structure_type" | "worldgen/surface_builder" | "worldgen/tree_decorator_type" | "worldgen/trunk_placer_type">;
    const ComplexSep = ":";
    function mock(range: core.RangeLike): ObjectiveCriteriaNode;
}
export interface ParticleNode extends core.AstNode {
    type: 'mcfunction:particle';
    children?: (core.ResourceLocationNode | core.FloatNode | core.IntegerNode | BlockNode | ItemStackNode | VectorNode | nbt.NbtCompoundNode)[];
    id: core.ResourceLocationNode;
}
export declare namespace ParticleNode {
    const SpecialTypes: Set<"block" | "item" | "block_marker" | "dust" | "dust_color_transition" | "falling_dust" | "sculk_charge" | "shriek" | "vibration">;
    export type SpecialType = typeof SpecialTypes extends Set<infer T> ? T : undefined;
    export function isSpecialType(type: string | undefined): type is SpecialType;
    export type OptionType = typeof SpecialTypes extends Set<infer T> ? T : undefined;
    export function requiresOptions(type: string | undefined, release: ReleaseVersion): type is OptionType;
    export function is(node: core.AstNode | undefined): node is ParticleNode;
    export function mock(range: core.RangeLike): ParticleNode;
    export {};
}
export interface ScoreHolderNode extends core.AstNode {
    type: 'mcfunction:score_holder';
    children: [core.LiteralNode | core.SymbolNode | EntitySelectorNode];
    fakeName?: core.SymbolNode;
    selector?: EntitySelectorNode;
    wildcard?: core.LiteralNode;
}
export declare namespace ScoreHolderNode {
    function mock(range: core.RangeLike): ScoreHolderNode;
}
export interface TimeNode extends core.AstNode {
    type: 'mcfunction:time';
    children: (core.FloatNode | core.LiteralNode)[];
    value: number;
    unit?: string;
}
export declare namespace TimeNode {
    const UnitToTicks: Map<string, number>;
    const Units: string[];
}
export interface UuidNode extends core.AstNode {
    type: 'mcfunction:uuid';
    bits: [bigint, bigint];
}
export interface VectorNode extends core.SequenceNode<CoordinateNode> {
    type: 'mcfunction:vector';
    options: VectorNode.Options;
    system: CoordinateSystem;
}
export declare namespace VectorNode {
    interface Options {
        dimension: 2 | 3;
        integersOnly?: boolean;
        noLocal?: boolean;
    }
    function mock(range: core.RangeLike, options: Options): VectorNode;
}
export {};
//# sourceMappingURL=argument.d.ts.map