export * from './common.js';
export * from './mcmeta.js';
import * as core from '@spyglassmc/core';
import { Fluids } from './mcmeta.js';
/* istanbul ignore next */
/**
 * Return the deserialized [`versions.json`][versions.json].
 *
 * [versions.json]: https://github.com/misode/mcmeta/blob/summary/versions/data.json
 */
export async function getVersions(externals, logger) {
    return (await core.fetchWithCache(externals, logger, 'https://api.spyglassmc.com/mcje/versions'))
        .json();
}
/* istanbul ignore next */
/**
 * Get vanilla resources, including block definitions, fluid definitions, command tree, and registries.
 *
 * @throws Network/file system errors.
 */
export async function getMcmetaSummary(externals, logger, version, overridePaths = {}) {
    async function handleOverride(currentValue, overrideConfig) {
        if (overrideConfig) {
            try {
                const override = (await core.fileUtil.readJson(externals, overrideConfig.path));
                if (overrideConfig.replace) {
                    return override;
                }
                else {
                    return core.merge(currentValue, override);
                }
            }
            catch (e) {
                logger.error(`[je] [mcmeta-overrides] Failed loading customized mcmeta summary file “${overrideConfig.path}”`, e);
            }
        }
        return currentValue;
    }
    const getResource = async (type, overrideConfig) => {
        const response = await core.fetchWithCache(externals, logger, `https://api.spyglassmc.com/mcje/versions/${encodeURIComponent(version)}/${type}`);
        return {
            data: await handleOverride(await response.json(), overrideConfig),
            checksum: response.headers.get('etag') ?? '',
        };
    };
    const [blocks, commands, fluids, registries] = [
        await getResource('block_states', overridePaths.blocks),
        await getResource('commands', overridePaths.commands),
        {
            data: await handleOverride(Fluids, overridePaths.fluids),
            checksum: 'v1',
        },
        await getResource('registries', overridePaths.registries),
    ];
    return {
        blocks: blocks.data,
        commands: commands.data,
        fluids: fluids.data,
        registries: registries.data,
        checksum: `${blocks.checksum}-${commands.checksum}-${fluids.checksum}-${registries.checksum}`,
    };
}
/* istanbul ignore next */
/**
 * @throws Network/file system errors.
 */
export async function getVanillaDatapack(externals, logger, version) {
    return {
        type: 'tarball-ram',
        name: 'vanilla-datapack',
        data: new Uint8Array(await (await core.fetchWithCache(externals, logger, `https://api.spyglassmc.com/mcje/versions/${encodeURIComponent(version)}/vanilla-data/tarball`)).arrayBuffer()),
        stripLevel: 0,
    };
}
/* istanbul ignore next */
/**
 * @throws Network/file system errors.
 */
export async function getVanillaResourcepack(externals, logger, version) {
    return {
        type: 'tarball-ram',
        name: 'vanilla-assets-tiny',
        data: new Uint8Array(await (await core.fetchWithCache(externals, logger, `https://api.spyglassmc.com/mcje/versions/${encodeURIComponent(version)}/vanilla-assets-tiny/tarball`)).arrayBuffer()),
        stripLevel: 0,
    };
}
/**
 * @throws Network/file system errors.
 */
export async function getVanillaMcdoc(externals, logger) {
    return {
        type: 'tarball-ram',
        name: 'vanilla-mcdoc',
        data: new Uint8Array(await (await core.fetchWithCache(externals, logger, `https://api.spyglassmc.com/vanilla-mcdoc/tarball`)).arrayBuffer()),
        stripLevel: 0,
    };
}
//# sourceMappingURL=index.js.map